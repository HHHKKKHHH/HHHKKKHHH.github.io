<!DOCTYPE html><html class="appearance-light" lang="zh-CN"><head><meta charset="UTF-8"><title>前端框架学习 -- 封装 is all you need</title><meta name="description" content="一个国内辣鸡985在读研究生的无聊记录，啥都想学啥都学不会。"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="../../../../images/avater.png"><link rel="stylesheet" href="../../../../style/common/bulma.css"><link rel="stylesheet" href="../../../../style/base.css"><link rel="stylesheet" href="../../../../style/common/helper.css"><script src="../../../../js/common.js"></script><link rel="stylesheet" href="../../../../style/post.css"><link rel="stylesheet" href="../../../../style/themes/highlight-theme-light.css"><script src="../../../../js/highlight.pack.js"></script><meta name="description" content="本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 


写在前面
本思路主要应用于以状态管理为核心的前端框架，包括但不限于 react, vue等 web 框架 以及 flutter, swift框架 等非 web 框架
对于框架对应编程语言的学习暂时不在讨论范围内，不过进行多讨论
标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷


封装 is all you need笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：

三个层次组件的封装方法
三个层次组件相互嵌套的方法

一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文
以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料.."><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="KH的无聊Playground" type="application/atom+xml">
<link rel="stylesheet" type="text/css" href="css/injector/main.css" /><link rel="preload" as="style" href="css/injector/light.css" /></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="../../../../index.html">kaihongH的playground</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">前端框架学习 -- 封装 is all you need</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="../../../../index.html">首页</a></h3><h3 class="is-inline-block"><a href="../../../../archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="../../../../index.html">首页</a></h3><h3 class="is-inline-block"><a href="../../../../archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-is-all-you-need"><span class="toc-text">封装 is all you need</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-text">什么是封装？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-text">封装的三个层次</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-text">静态组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-text">函数组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-text">状态组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-2"><span class="toc-text">举例</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="../../../../tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B"><i class="tag post-item-tag">前端工程</i></a><a href="../../../../tags/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF"><i class="tag post-item-tag">学习思路</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">前端框架学习 -- 封装 is all you need</h1><time class="has-text-grey" datetime="2021-10-10T05:25:30.000Z">2021-10-10</time><article class="mt-2 post-content"><p>本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 </p>
<span id="more"></span>

<div class="admonition note"><p class="admonition-title">写在前面
</p><p>本思路主要应用于<code>以状态管理为核心</code>的前端框架，包括但不限于 <code>react</code>, <code>vue</code>等 web 框架 以及 <code>flutter</code>, <code>swift框架</code> 等非 web 框架</p>
<p>对于<code>框架对应编程语言的学习</code>暂时不在讨论范围内，不过进行多讨论</p>
<p>标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷</p>
</div>

<h1 id="封装-is-all-you-need"><a href="#封装-is-all-you-need" class="headerlink" title="封装 is all you need"></a>封装 is all you need</h1><p>笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：</p>
<ol>
<li>三个层次组件的封装方法</li>
<li>三个层次组件相互嵌套的方法</li>
</ol>
<p>一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文</p>
<div class="admonition info"><p>以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料，不同层次的封装就如水泥钢筋等不同材料，而组件的嵌套是材料使用的流程</p>
</div>

<h1 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a>什么是封装？</h1><p>在正式介绍学习思路之前，首先要先总结下前端开发(非限定前端框架)中的“组件封装”</p>
<blockquote><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体</p>
<footer><strong>wiki 百科</strong></footer></blockquote>
<p>在开发过程中，个人认为“封装”的意义关键在于“复用”，是<code>面向对象编程</code>思想的一种表层体现。</p>
<p>换而言之，如果一个项目的开发需求中几乎不存在可复用的“部分”，那么可以完全抛弃“封装”的概念，采用<code>面向过程编程</code>的思路<br>但如果同一个“部分”不断出现在项目中，那我们应该考虑对他进行抽象其封装来减少维护难度，提高代码鲁棒性。</p>
<p>具体到前端开发中的封装组件，往往是 UI 和交互逻辑的抽象结合体，典型的例子有如 <a target="_blank" rel="noopener" href="https://material.io/components/lists">material 提供的 List 组件</a>: </p>
<ol>
<li>提供了统一的样式渲染模版</li>
<li>透明化内部交互逻辑以及样式渲染</li>
<li>具有一定的样式或逻辑自定义 API</li>
</ol>
<p>当然，简单功能的纯 UI 组件封装也是十分常见，典型的例子有如 <a target="_blank" rel="noopener" href="https://ant.design/components/typography-cn/">ant design 提供的 Typography 组件</a></p>
<p>而纯逻辑封装对于开源资源则较为少见，一是部分前端框架并不提供完全剥离 UI 而只抽象逻辑的封装能力（说的就是你，vue2）；二是单纯的逻辑封装往往意味着与业务逻辑的强耦合关系，很难跨项目通用；三是对于纯逻辑组件意味着更复杂的项目抽象层次与更高的心智成本，大多数时候懒是第一阻力（🐶</p>
<p>对于纯逻辑封装的典型例子，我想在 <a href="">react hook 的抽象组件封装</a>中单独探讨</p>
<div class="admonition info"><p>需要注意的是，这里提到的 UI 与 逻辑的抽象封装仅仅只是对封装概念的举例，并不是“封装层次”的总结。笔者想表达的封装层次区分在下一节中介绍</p>
</div>

<h1 id="封装的三个层次"><a href="#封装的三个层次" class="headerlink" title="封装的三个层次"></a>封装的三个层次</h1><p>学习思路的第一步，了解待学习前端框架三个层次组件的封装方法。下面将结合具体框架中的封装例子从“低层次”到“高层次”分别介绍三种封装层次<br>以下代码举例将主要为 typescript 版本的 react 与 flutter 框架中的代码</p>
<div class="admonition info"><p>三个层次的名称系笔者自己 yy，可能与专业术语撞车，可能不够贴切，还请见谅</p>
</div>

<h2 id="静态组件"><a href="#静态组件" class="headerlink" title="静态组件"></a>静态组件</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>无参数且本身在生命周期中不会也不能变化的组件</p>
</blockquote>
<p>作为最低层次的封装，静态组件的概念较为简单。从编程语言角度，其实<code>常量</code>本身也是一种静态组件。<br>这样的封装看似意义不大，但是回到上文对于封装必要性的描述，静态组件可以指代一个全局使用的“颜色”，一个全局默认“参数”或是一个重复使用的“样式”等等</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>在大多数前端框架的大多数使用场景中，静态组件的声明和使用与变量无异，在这里就不过多赘述了。</p>
<pre><div class="caption"><span>react</span></div><code class="hljs typescript"><span class="hljs-keyword">const</span> primaryColor: <span class="hljs-built_in">string</span>  = <span class="hljs-string">&quot;#13acd9&quot;</span>  
<span class="hljs-keyword">const</span> breakpoint = <span class="hljs-string">&quot;1000px&quot;</span> 
<span class="hljs-keyword">const</span> standardSpace = <span class="hljs-function">()=&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;width:</span>&quot;<span class="hljs-attr">2rem</span>&quot;,<span class="hljs-attr">height:</span>&quot;<span class="hljs-attr">1rem</span>&quot;&#125;&#125;/&gt;</span></span></code></pre>

<pre><div class="caption"><span>flutter</span></div><code class="hljs dart">Color primaryBlue = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">0xFF13ACD9</span>);
Color primaryRed = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">0xFFFF8585</span>);
Color primaryGreen = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">0xFF27AE60</span>);
Divider standardDivider = <span class="hljs-keyword">new</span> Divider(
  height: <span class="hljs-number">2</span>,
  color: Color(<span class="hljs-number">0x15000000</span>),
);</code></pre>

<h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>有参数且本身在生命周期中不会也不能变化的组件</p>
</blockquote>
<p>在代码层次上，相比静态组件，函数组件本身不再是完全不变的，在实例化时可以接受参数。这给予了函数组件更多的自定义空间<br>但是需要注意的是，顾名思义，函数组件在实例化之后便无法发生变化（如函数执行完成后便退出执行栈，再次执行已经是另一个实例了）</p>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>在笔者看来，函数组件其实是在大多数前端工程中使用最多的，但是很容易用而不自知，因为函数组件的心智成本很低（随便就写了，随便就用了）<br>对于函数组件的深层讨论，我们会在下文介绍状态组件后进行</p>
<pre><div class="caption"><span>react</span></div><code class="hljs typescript"><span class="hljs-comment">// 一个可以接受参数的占位盒子</span>
<span class="hljs-keyword">const</span> SizeBox = <span class="hljs-function">(<span class="hljs-params">&#123; height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span> &#125;</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> <span class="hljs-attr">height</span>, <span class="hljs-attr">width:</span> <span class="hljs-attr">width</span> &#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&#125;

<span class="hljs-comment">// 一个上传流程中抽象的封装逻辑</span>
<span class="hljs-keyword">const</span> getUploadUrl = <span class="hljs-keyword">async</span> (fileName: <span class="hljs-built_in">string</span>, <span class="hljs-attr">api</span>: AxiosInstance) =&gt; &#123;
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> api.get(<span class="hljs-string">&#x27;/static/upload&#x27;</span>, &#123; <span class="hljs-attr">params</span>: &#123; fileName &#125; &#125;)
  <span class="hljs-keyword">if</span> (!res.data.success) &#123;
    message.error(res.data.reason)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  &#125;
  <span class="hljs-comment">// console.log(&#x27;geturl&#x27;, res);</span>
  <span class="hljs-keyword">return</span> res.data.result?.url
&#125;</code></pre>

<pre><div class="caption"><span>flutter</span></div><code class="hljs dart"><span class="hljs-comment">// 压缩文件对象的抽象逻辑封装</span>
Future&lt;File&gt; compressFile(File file) <span class="hljs-keyword">async</span> &#123;
  Directory dir = <span class="hljs-keyword">await</span> getTemporaryDirectory();
  <span class="hljs-built_in">String</span> fileType = file.absolute.path.split(<span class="hljs-string">&#x27;.&#x27;</span>).last;
  File result = <span class="hljs-keyword">await</span> FlutterImageCompress.compressAndGetFile(
    file.absolute.path,
    dir.absolute.path +
        <span class="hljs-string">&quot;/&quot;</span> +<span class="hljs-built_in">DateTime</span>.now().millisecondsSinceEpoch.toString() +<span class="hljs-string">&quot;.&quot;</span> +
        fileType,
    quality: <span class="hljs-number">88</span>,
  );
  <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-comment">// 可以定义高度的分割线</span>
Divider standardDivider(<span class="hljs-built_in">double</span> height,Color color=Color(<span class="hljs-number">0x15000000</span>))&#123;
  <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> Divider(
  height: height,
  color:  color,
);
&#125; 
</code></pre>

<h2 id="状态组件"><a href="#状态组件" class="headerlink" title="状态组件"></a>状态组件</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>有参数（或隐式的状态初值传参）且本身在生命周期中能持有变量（可变化）的组件</p>
</blockquote>
<p>状态组件从编程思想来看，是“面向对象编程”思想的体现；从前端框架的角度来说，笔者觉得完整的状态管理流程链是区分一个前端框架“现代”与否的关键性标准。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="../../09/%E6%9D%82%E8%B0%88-%E6%87%92%E4%BA%BA%E7%9A%84-TODO-LIST-10/" title="懒人的 TODO LIST"><span class="has-text-weight-semibold">下一页: 懒人的 TODO LIST</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/hhhkkkhhh"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> kaihongH 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p></div><div><span>止于至善</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="../../../../js/post.js"></script></body></html>