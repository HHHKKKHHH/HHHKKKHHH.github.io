{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-Claudia/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","path":"style/about.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","path":"style/archive.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","path":"style/base.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/note.scss","path":"style/note.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","path":"style/post.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","path":"style/widget-header.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","path":"style/widget-post-list.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","path":"style/common/bulma.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","path":"style/common/helper.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","path":"style/common/variable.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","path":"style/themes/default-dark.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","path":"style/themes/default-light.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","path":"style/themes/highlight-theme-light.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","path":"style/themes/theme.scss","modified":0,"renderable":1},{"_id":"source/.nojekyll","path":".nojekyll","modified":0,"renderable":0},{"_id":"source/images/bg-1.png","path":"images/bg-1.png","modified":0,"renderable":0},{"_id":"source/images/avater.jpg","path":"images/avater.jpg","modified":0,"renderable":0},{"_id":"source/images/bg-2.png","path":"images/bg-2.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633678001810},{"_id":"source/.DS_Store","hash":"6702459630b69cda9d5ecd2979066d80fc48e82a","modified":1633678053017},{"_id":"source/images/.DS_Store","hash":"2cff7e9d73e44c31f48ce649b285cb8e487d2ad8","modified":1633678058034},{"_id":"source/images/avater.jpg","hash":"080d84567479c33e0320e567c6a04861ed0829bc","modified":1601368780319},{"_id":"source/_posts/工程向/前端框架思路总结-10.md","hash":"0718bb7ef3160a968314d6740cdcdbe74beee286","modified":1635125369350},{"_id":"source/_posts/杂谈/hello-world.md","hash":"c3dcd89e3bd618e9557bbb0119c631c9e79ee0a9","modified":1633754072434},{"_id":"source/_posts/杂谈/懒人的-TODO-LIST-10.md","hash":"6a8aeedf61157e2478d5e51ca484eaa783520e85","modified":1635125284982},{"_id":"source/_posts/人工智能/概论/初中人工智能教程-头脑风暴-10.md","hash":"173bb150c0b0cb282d9b8d9052c2582d66d95478","modified":1633844016916},{"_id":"themes/hexo-theme-Claudia/.gitignore","hash":"bd20d54c57507594cd16a21021c3600f9311a1f5","modified":1633696635553},{"_id":"themes/hexo-theme-Claudia/CHANGELOG.md","hash":"6a2a5c3e4399d19fa06c175bc7e78c9b18413251","modified":1633696635553},{"_id":"themes/hexo-theme-Claudia/CODE_OF_CONDUCT.md","hash":"787b987cd6079f93c7846b69c3b4dfa41cb3ac03","modified":1633696635554},{"_id":"themes/hexo-theme-Claudia/CONTRIBUTING.md","hash":"618215987cc9a774c37cc70efa1cb8545457a49c","modified":1633696635554},{"_id":"themes/hexo-theme-Claudia/LICENSE","hash":"9812afb9d0aa8596067b6fd30cf6089345b7b678","modified":1633696635555},{"_id":"themes/hexo-theme-Claudia/README-CN.md","hash":"2dddb18f2761b5e495d6f71ab9880797af839926","modified":1633696635555},{"_id":"themes/hexo-theme-Claudia/README.md","hash":"17911c948337830658d8322b6b9e37e8431b7b64","modified":1633696635556},{"_id":"themes/hexo-theme-Claudia/_config.yml","hash":"61425ab5eb0c766f27102c68de632cbb376ee395","modified":1635125832090},{"_id":"themes/hexo-theme-Claudia/package.json","hash":"c59cb2089c51ed56deb2df69171d7adc63c1148f","modified":1633696635563},{"_id":"themes/hexo-theme-Claudia/.github/FUNDING.yml","hash":"dd672081ec4678929f6c1ac3ebbef4d990291ecd","modified":1633696635552},{"_id":"themes/hexo-theme-Claudia/.github/PULL_REQUEST_TEMPLATE.md","hash":"35751990a36fffe5a5f6fd682452fe5594cadde9","modified":1633696635553},{"_id":"themes/hexo-theme-Claudia/layout/about.pug","hash":"98dea176f76053d5deaf35ed25518d218d70be7d","modified":1633696635557},{"_id":"themes/hexo-theme-Claudia/languages/zh-CN.yml","hash":"9d8b1f0a337f56907aadddf406c5977435d34fc1","modified":1633696635556},{"_id":"themes/hexo-theme-Claudia/languages/en.yml","hash":"a2476669bc4171cd4f343e47c8dc6821b779aaff","modified":1633696635556},{"_id":"themes/hexo-theme-Claudia/layout/archive.pug","hash":"68c709495bc39a659d9c4b19216714a5ac2b5579","modified":1633696635558},{"_id":"themes/hexo-theme-Claudia/layout/category.pug","hash":"2147f3d66640bc6604c9b15325a480d196a4df3d","modified":1633696635558},{"_id":"themes/hexo-theme-Claudia/layout/index.pug","hash":"b84b3b89b3ecd0f3c604c2517ccd694d6a8489f4","modified":1633696635558},{"_id":"themes/hexo-theme-Claudia/layout/page.pug","hash":"6c5db904a03adb4794b7ada222389da12d395bc7","modified":1633696635558},{"_id":"themes/hexo-theme-Claudia/layout/post.pug","hash":"c76194840b5d6b7b881651cb492ab4b6963d1725","modified":1633696635559},{"_id":"themes/hexo-theme-Claudia/layout/tag.pug","hash":"16dac6e0a6ef939ceb6adb21dfbe0276538ff269","modified":1633696635559},{"_id":"themes/hexo-theme-Claudia/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1633696635573},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/bug_report.md","hash":"b38365fec9b6cac6bbb75441082f041c4efd35bf","modified":1633696635552},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/feature_request.md","hash":"9d8447814c3ac93d7fbd336015e7ef80c4a32831","modified":1633696635553},{"_id":"themes/hexo-theme-Claudia/layout/widget/methods.pug","hash":"fa62f6ad95d1a4cda5038595d19d4d11b4b39e17","modified":1633696635560},{"_id":"themes/hexo-theme-Claudia/layout/widget/base.pug","hash":"4dd0e47b3eac944e00773cbe9fb7946202ac261e","modified":1633755135074},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-archives.pug","hash":"e6bcf8b09a5e06119baf3f97f7798ef7600ab65c","modified":1633696635560},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-header.pug","hash":"2bd595283a51e06843e8eda7bb54946fcc87492a","modified":1633755127275},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-categories.pug","hash":"ea3bcd5f5fb06e26d8b67f30f224e7c129672980","modified":1633696635561},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-post-list.pug","hash":"f034a4b8231f7933d06e364671b11847c74b9a5c","modified":1633696635561},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-profile.pug","hash":"fbe18f3dd5e8d2850f8e6510da4fbd499d5096f0","modified":1633696635561},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-recent.pug","hash":"7512dceae690ea219d562a6e450d633e29916072","modified":1633696635562},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-search.pug","hash":"c17612dd4ae2d439d757818ec0e4215d71dd9ad5","modified":1633696635562},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-sns.pug","hash":"8ec154d321b36a5f3bf5974c75668b45ec660c1d","modified":1633696635562},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-tag.pug","hash":"714a05148758e1e3cc12635c875cb6ef1753c6ab","modified":1633696635563},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","hash":"4a1beebb317c598b11fc4815e70b07bbb6d2aed7","modified":1633696635575},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","hash":"cd1dc16dfa7c482cc88ddabaf8c9a459299a98cf","modified":1633696635576},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","hash":"ef3e27e76e77831fab61aba50ac75ccb99766c5b","modified":1633849744051},{"_id":"themes/hexo-theme-Claudia/source/style/note.scss","hash":"85bea65a94a46b114fe93ee6768f5936327ab17f","modified":1633850042087},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","hash":"8a3520a0ceb22a2fde35b09485e2df6dd5a23b6f","modified":1633696635579},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","hash":"18782c2ab206abbeb0ee59632864251acfd20d85","modified":1633696635580},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","hash":"db24becef1636806767dfaa33b3f90c40450de8d","modified":1633696635581},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","hash":"7f62c8c148ee0b528a2bea47b248b2a7f5501142","modified":1633696635573},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","hash":"04edd583f103ba444d8174d55e7f45e27b8f2549","modified":1633696635575},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","hash":"7cd0982fe839e760523f8f85ea6f06f2b5d2111a","modified":1633696635578},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","hash":"fd76a1185c32c7b7dea76554af5ff3c035a3517a","modified":1635147137415},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","hash":"0cbdc5738503f55e5b84e1bd00e445c98c7d56d2","modified":1633696635579},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","hash":"3ed681c72fe04e8d29f39b354d4a5826d5c344fd","modified":1635147208706},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1633696635580},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","hash":"2abd4338f8be6053255c6d0c797f715e7cd99321","modified":1635147134004},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","hash":"2ef9bbbc688ce413686ce0eb64d0b25af4ea34e2","modified":1633696635575},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1633696635578},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover.png","hash":"757680cd3648e3569d6a18abaf33180dc427d620","modified":1633696635572},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover-v2.png","hash":"f477d90d327a638a46b3caa172332e931955a532","modified":1633696635568},{"_id":"source/images/bg-1.png","hash":"e947c9698b15a90c39160e01187a82debc09273b","modified":1633366069000},{"_id":"source/images/bg-2.png","hash":"05f47d119bb44b3f2eb5a4538d5f8bb96cfa2217","modified":1633366328000},{"_id":"public/atom.xml","hash":"f01b72255fb4c1059c7f1a97eb514548d35f0eb9","modified":1650817959833},{"_id":"public/search.xml","hash":"068d010edd7f2d8bed2635affb0e7165e2d700cb","modified":1650817959833},{"_id":"public/css/injector/main.css","hash":"6f5f47ab322b30dc4796b84a3bdb37545c44e220","modified":1633878657739},{"_id":"public/css/injector/light.css","hash":"6f5f47ab322b30dc4796b84a3bdb37545c44e220","modified":1633878657739},{"_id":"public/2021/10/10/工程向-前端框架思路总结-10/index.html","hash":"0b972822a9726577a7308de566262b679387badd","modified":1650817959833},{"_id":"public/2021/10/09/杂谈-懒人的-TODO-LIST-10/index.html","hash":"0e8aac6f85962dbbaa68611f935411a51a5157c4","modified":1650817959833},{"_id":"public/2021/10/05/人工智能-概论-初中人工智能教程-头脑风暴-10/index.html","hash":"888d8234baffd9e04e57ae814a5fc0cd4390c3b3","modified":1650817959833},{"_id":"public/2021/10/04/杂谈-hello-world/index.html","hash":"166721dc1fbe0289be40fecc0f0529a1bf9190ef","modified":1635125871749},{"_id":"public/archives/index.html","hash":"efd5d2d7489b897f672cb11db4f54a65501a7bce","modified":1650817959833},{"_id":"public/archives/2021/index.html","hash":"200201056b51d11c39d17248e56503ba65a33828","modified":1650817959833},{"_id":"public/archives/2021/10/index.html","hash":"fa47c0b96f93e25df892ca489f1138a3e3e4abd7","modified":1650817959833},{"_id":"public/categories/工程向/index.html","hash":"9acf8912da088a3723729c2fd95ce4e85436ed9a","modified":1650817959833},{"_id":"public/categories/杂谈/index.html","hash":"3688b027ac65664c8f98e09efcd50745f26803d5","modified":1650817959833},{"_id":"public/categories/人工智能/index.html","hash":"78a0a4fa430777af5caa6b2f978f3585bc4add80","modified":1650817959833},{"_id":"public/categories/人工智能/概论/index.html","hash":"d7d8e06c53c2dbabe9a293ff5994a7cf513ca5f6","modified":1650817959833},{"_id":"public/tags/前端工程/index.html","hash":"95b3623f4f1c53f25c2ec86cb691a72847ee26bc","modified":1650817959833},{"_id":"public/tags/学习思路/index.html","hash":"0bbb737da47842c155909e2f2fc144fdc3bb407d","modified":1650817959833},{"_id":"public/tags/机器学习/index.html","hash":"2a149e003eb10577e84bac29e71f934427ccc872","modified":1650817959833},{"_id":"public/index.html","hash":"d9e45db4e3988887bf21ef8c982293d224f423c1","modified":1650817959833},{"_id":"public/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633878657739},{"_id":"public/tags/人工智能/index.html","hash":"6313b5ab16e52a6ab00d41b4a757ab085b69b0f9","modified":1650817959833},{"_id":"public/tags/杂七杂八/index.html","hash":"580f38d090bf438df7a061d42aeded8ba709f670","modified":1650817959833},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1633878657739},{"_id":"public/images/avater.jpg","hash":"080d84567479c33e0320e567c6a04861ed0829bc","modified":1633878657739},{"_id":"public/style/about.css","hash":"be77ba5f4a125b94a487884cd66aaf2d10dbd8cd","modified":1633878657739},{"_id":"public/style/base.css","hash":"a42267442282a846fe1521ef07b4e7ea79801497","modified":1633878657739},{"_id":"public/style/post.css","hash":"42057cd7a90821105728c7f5959f455ec1cf0337","modified":1633878657739},{"_id":"public/style/note.css","hash":"b4708e4fb86ba39a6169e7f20a94051d7480c1f3","modified":1633878657739},{"_id":"public/style/archive.css","hash":"d18a9c8eef4f28c787462a0718c5afec865553a1","modified":1633878657739},{"_id":"public/style/widget-header.css","hash":"03af4d4589354d7eb4a04b0e81df98a783eaa31b","modified":1633878657739},{"_id":"public/style/widget-post-list.css","hash":"0a4988085ce419c5cb203c7da974d82c83c19afc","modified":1633878657739},{"_id":"public/style/common/helper.css","hash":"072cd37d6e2878dca4ccd96c3fb5e19165b9edac","modified":1633878657739},{"_id":"public/js/post.js","hash":"04edd583f103ba444d8174d55e7f45e27b8f2549","modified":1633878657739},{"_id":"public/js/common.js","hash":"7f62c8c148ee0b528a2bea47b248b2a7f5501142","modified":1633878657739},{"_id":"public/style/common/variable.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633878657739},{"_id":"public/style/themes/default-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633878657739},{"_id":"public/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1633878657739},{"_id":"public/style/themes/default-light.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633878657739},{"_id":"public/style/themes/theme.css","hash":"d8d9e55799268ba5311caae5a3fb620d89d89ae8","modified":1633878657739},{"_id":"public/js/highlight.pack.js","hash":"2ef9bbbc688ce413686ce0eb64d0b25af4ea34e2","modified":1633878657739},{"_id":"public/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1633878657739},{"_id":"public/images/bg-1.png","hash":"e947c9698b15a90c39160e01187a82debc09273b","modified":1633878657739},{"_id":"public/images/bg-2.png","hash":"05f47d119bb44b3f2eb5a4538d5f8bb96cfa2217","modified":1633878657739},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.png","hash":"ed705bd33251f8f2aa1ad45bf0885f2a18c1ce52","modified":1635125814383},{"_id":"public/images/favicon.png","hash":"ed705bd33251f8f2aa1ad45bf0885f2a18c1ce52","modified":1635125871749},{"_id":"source/_posts/杂谈/对人工智能哲学的讨论与一点拙见.md","hash":"cec811665224450b5bd01fea9d7f335f56444296","modified":1650817950337},{"_id":"public/archives/2022/index.html","hash":"f323ccc88d3d640606084fea53bee267fe914a8d","modified":1650817959833},{"_id":"public/archives/2022/04/index.html","hash":"45069ac457f7ef39c64d6d8865f9045544646300","modified":1650817959833},{"_id":"public/2022/04/24/杂谈-对人工智能哲学的讨论与一点拙见/index.html","hash":"aec04d9a58360cda1c2c2e4acca42fd012e9848b","modified":1650817959833},{"_id":"public/tags/人工智能哲学/index.html","hash":"f78518eec5c734fd1faa11c6b3d4480d0dcbf730","modified":1650817959833}],"Category":[{"name":"工程向","_id":"ckuld61r80002y96hedd6cklw"},{"name":"杂谈","_id":"ckuld61rc0006y96h58qe8sdj"},{"name":"人工智能","_id":"ckuld61rd0009y96h6c8z1np2"},{"name":"概论","parent":"ckuld61rd0009y96h6c8z1np2","_id":"ckuld61rf000gy96hf77wgw9e"}],"Data":[],"Page":[],"Post":[{"title":"前端框架学习 -- 封装 is all you need","date":"2021-10-10T05:25:30.000Z","_content":"\n本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 \n<!-- more -->\n\n!!! note 写在前面\n    本思路主要应用于`以状态管理为核心`的前端框架，包括但不限于 `react`, `vue`等 web 框架 以及 `flutter`, `swift框架` 等非 web 框架\n\n    对于`框架对应编程语言的学习`暂时不在讨论范围内，不过进行多讨论\n\n    标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷\n\n# 封装 is all you need\n笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：\n1. 三个层次组件的封装方法\n2. 三个层次组件相互嵌套的方法\n\n一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文\n\n!!! info \"\"\n    以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料，不同层次的封装就如水泥钢筋等不同材料，而组件的嵌套是材料使用的流程\n\n\n\n# 什么是封装？\n在正式介绍学习思路之前，首先要先总结下前端开发(非限定前端框架)中的“组件封装”\n{% blockquote  wiki 百科 %}\n封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体\n{% endblockquote %}\n在开发过程中，个人认为“封装”的意义关键在于“复用”，是`面向对象编程`思想的一种表层体现。\n\n换而言之，如果一个项目的开发需求中几乎不存在可复用的“部分”，那么可以完全抛弃“封装”的概念，采用`面向过程编程`的思路\n但如果同一个“部分”不断出现在项目中，那我们应该考虑对他进行抽象其封装来减少维护难度，提高代码鲁棒性。\n\n具体到前端开发中的封装组件，往往是 UI 和交互逻辑的抽象结合体，典型的例子有如 [material 提供的 List 组件](https://material.io/components/lists): \n1. 提供了统一的样式渲染模版\n2. 透明化内部交互逻辑以及样式渲染\n3. 具有一定的样式或逻辑自定义 API\n\n当然，简单功能的纯 UI 组件封装也是十分常见，典型的例子有如 [ant design 提供的 Typography 组件](https://ant.design/components/typography-cn/)\n\n而纯逻辑封装对于开源资源则较为少见，一是部分前端框架并不提供完全剥离 UI 而只抽象逻辑的封装能力（说的就是你，vue2）；二是单纯的逻辑封装往往意味着与业务逻辑的强耦合关系，很难跨项目通用；三是对于纯逻辑组件意味着更复杂的项目抽象层次与更高的心智成本，大多数时候懒是第一阻力（🐶\n\n对于纯逻辑封装的典型例子，我想在 [react hook 的抽象组件封装]()中单独探讨\n\n!!! info \"\"\n    需要注意的是，这里提到的 UI 与 逻辑的抽象封装仅仅只是对封装概念的举例，并不是“封装层次”的总结。笔者想表达的封装层次区分在下一节中介绍\n\n# 封装的三个层次\n学习思路的第一步，了解待学习前端框架三个层次组件的封装方法。下面将结合具体框架中的封装例子从“低层次”到“高层次”分别介绍三种封装层次\n以下代码举例将主要为 typescript 版本的 react 与 flutter 框架中的代码\n\n!!! info \"\"\n    三个层次的名称系笔者自己 yy，可能与专业术语撞车，可能不够贴切，还请见谅\n\n## 静态组件\n### 定义\n> 无参数且本身在生命周期中不会也不能变化的组件\n\n作为最低层次的封装，静态组件的概念较为简单。从编程语言角度，其实`常量`本身也是一种静态组件。\n这样的封装看似意义不大，但是回到上文对于封装必要性的描述，静态组件可以指代一个全局使用的“颜色”，一个全局默认“参数”或是一个重复使用的“样式”等等\n\n\n\n### 举例 \n在大多数前端框架的大多数使用场景中，静态组件的声明和使用与变量无异，在这里就不过多赘述了。\n\n```typescript react\nconst primaryColor: string  = \"#13acd9\"  \nconst breakpoint = \"1000px\" \nconst standardSpace = ()=><div style={{width:\"2rem\",height:\"1rem\"}}/>\n```\n\n```dart flutter \nColor primaryBlue = new Color(0xFF13ACD9);\nColor primaryRed = new Color(0xFFFF8585);\nColor primaryGreen = new Color(0xFF27AE60);\nDivider standardDivider = new Divider(\n  height: 2,\n  color: Color(0x15000000),\n);\n```\n\n## 函数组件\n### 定义\n> 有参数且本身在生命周期中不会也不能变化的组件\n\n在代码层次上，相比静态组件，函数组件本身不再是完全不变的，在实例化时可以接受参数。这给予了函数组件更多的自定义空间\n但是需要注意的是，顾名思义，函数组件在实例化之后便无法发生变化（如函数执行完成后便退出执行栈，再次执行已经是另一个实例了）\n\n\n### 举例 \n\n在笔者看来，函数组件其实是在大多数前端工程中使用最多的，但是很容易用而不自知，因为函数组件的心智成本很低（随便就写了，随便就用了）\n对于函数组件的深层讨论，我们会在下文介绍状态组件后进行\n```typescript react\n// 一个可以接受参数的占位盒子\nconst SizeBox = ({ height = 0, width = 0 }) => {\n  return <div style={{ height: height, width: width }}></div>\n}\n\n// 一个上传流程中抽象的封装逻辑\nconst getUploadUrl = async (fileName: string, api: AxiosInstance) => {\n  const res = await api.get('/static/upload', { params: { fileName } })\n  if (!res.data.success) {\n    message.error(res.data.reason)\n    return null\n  }\n  // console.log('geturl', res);\n  return res.data.result?.url\n}\n```\n\n```dart flutter \n// 压缩文件对象的抽象逻辑封装\nFuture<File> compressFile(File file) async {\n  Directory dir = await getTemporaryDirectory();\n  String fileType = file.absolute.path.split('.').last;\n  File result = await FlutterImageCompress.compressAndGetFile(\n    file.absolute.path,\n    dir.absolute.path +\n        \"/\" +DateTime.now().millisecondsSinceEpoch.toString() +\".\" +\n        fileType,\n    quality: 88,\n  );\n  return result;\n}\n\n// 可以定义高度的分割线\nDivider standardDivider(double height,Color color=Color(0x15000000)){\n  return  new Divider(\n  height: height,\n  color:  color,\n);\n} \n\n```\n\n## 状态组件\n### 定义\n> 有参数（或隐式的状态初值传参）且本身在生命周期中能持有变量（可变化）的组件\n\n状态组件从编程思想来看，是“面向对象编程”思想的体现；从前端框架的角度来说，笔者觉得完整的状态管理流程链是区分一个前端框架“现代”与否的关键性标准。\n### 举例\n","source":"_posts/工程向/前端框架思路总结-10.md","raw":"---\ntitle: 前端框架学习 -- 封装 is all you need\ntags:\n  - 前端工程\n  - 学习思路\ncategories:\n  - 工程向\ndate: 2021-10-10 13:25:30\n---\n\n本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 \n<!-- more -->\n\n!!! note 写在前面\n    本思路主要应用于`以状态管理为核心`的前端框架，包括但不限于 `react`, `vue`等 web 框架 以及 `flutter`, `swift框架` 等非 web 框架\n\n    对于`框架对应编程语言的学习`暂时不在讨论范围内，不过进行多讨论\n\n    标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷\n\n# 封装 is all you need\n笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：\n1. 三个层次组件的封装方法\n2. 三个层次组件相互嵌套的方法\n\n一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文\n\n!!! info \"\"\n    以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料，不同层次的封装就如水泥钢筋等不同材料，而组件的嵌套是材料使用的流程\n\n\n\n# 什么是封装？\n在正式介绍学习思路之前，首先要先总结下前端开发(非限定前端框架)中的“组件封装”\n{% blockquote  wiki 百科 %}\n封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体\n{% endblockquote %}\n在开发过程中，个人认为“封装”的意义关键在于“复用”，是`面向对象编程`思想的一种表层体现。\n\n换而言之，如果一个项目的开发需求中几乎不存在可复用的“部分”，那么可以完全抛弃“封装”的概念，采用`面向过程编程`的思路\n但如果同一个“部分”不断出现在项目中，那我们应该考虑对他进行抽象其封装来减少维护难度，提高代码鲁棒性。\n\n具体到前端开发中的封装组件，往往是 UI 和交互逻辑的抽象结合体，典型的例子有如 [material 提供的 List 组件](https://material.io/components/lists): \n1. 提供了统一的样式渲染模版\n2. 透明化内部交互逻辑以及样式渲染\n3. 具有一定的样式或逻辑自定义 API\n\n当然，简单功能的纯 UI 组件封装也是十分常见，典型的例子有如 [ant design 提供的 Typography 组件](https://ant.design/components/typography-cn/)\n\n而纯逻辑封装对于开源资源则较为少见，一是部分前端框架并不提供完全剥离 UI 而只抽象逻辑的封装能力（说的就是你，vue2）；二是单纯的逻辑封装往往意味着与业务逻辑的强耦合关系，很难跨项目通用；三是对于纯逻辑组件意味着更复杂的项目抽象层次与更高的心智成本，大多数时候懒是第一阻力（🐶\n\n对于纯逻辑封装的典型例子，我想在 [react hook 的抽象组件封装]()中单独探讨\n\n!!! info \"\"\n    需要注意的是，这里提到的 UI 与 逻辑的抽象封装仅仅只是对封装概念的举例，并不是“封装层次”的总结。笔者想表达的封装层次区分在下一节中介绍\n\n# 封装的三个层次\n学习思路的第一步，了解待学习前端框架三个层次组件的封装方法。下面将结合具体框架中的封装例子从“低层次”到“高层次”分别介绍三种封装层次\n以下代码举例将主要为 typescript 版本的 react 与 flutter 框架中的代码\n\n!!! info \"\"\n    三个层次的名称系笔者自己 yy，可能与专业术语撞车，可能不够贴切，还请见谅\n\n## 静态组件\n### 定义\n> 无参数且本身在生命周期中不会也不能变化的组件\n\n作为最低层次的封装，静态组件的概念较为简单。从编程语言角度，其实`常量`本身也是一种静态组件。\n这样的封装看似意义不大，但是回到上文对于封装必要性的描述，静态组件可以指代一个全局使用的“颜色”，一个全局默认“参数”或是一个重复使用的“样式”等等\n\n\n\n### 举例 \n在大多数前端框架的大多数使用场景中，静态组件的声明和使用与变量无异，在这里就不过多赘述了。\n\n```typescript react\nconst primaryColor: string  = \"#13acd9\"  \nconst breakpoint = \"1000px\" \nconst standardSpace = ()=><div style={{width:\"2rem\",height:\"1rem\"}}/>\n```\n\n```dart flutter \nColor primaryBlue = new Color(0xFF13ACD9);\nColor primaryRed = new Color(0xFFFF8585);\nColor primaryGreen = new Color(0xFF27AE60);\nDivider standardDivider = new Divider(\n  height: 2,\n  color: Color(0x15000000),\n);\n```\n\n## 函数组件\n### 定义\n> 有参数且本身在生命周期中不会也不能变化的组件\n\n在代码层次上，相比静态组件，函数组件本身不再是完全不变的，在实例化时可以接受参数。这给予了函数组件更多的自定义空间\n但是需要注意的是，顾名思义，函数组件在实例化之后便无法发生变化（如函数执行完成后便退出执行栈，再次执行已经是另一个实例了）\n\n\n### 举例 \n\n在笔者看来，函数组件其实是在大多数前端工程中使用最多的，但是很容易用而不自知，因为函数组件的心智成本很低（随便就写了，随便就用了）\n对于函数组件的深层讨论，我们会在下文介绍状态组件后进行\n```typescript react\n// 一个可以接受参数的占位盒子\nconst SizeBox = ({ height = 0, width = 0 }) => {\n  return <div style={{ height: height, width: width }}></div>\n}\n\n// 一个上传流程中抽象的封装逻辑\nconst getUploadUrl = async (fileName: string, api: AxiosInstance) => {\n  const res = await api.get('/static/upload', { params: { fileName } })\n  if (!res.data.success) {\n    message.error(res.data.reason)\n    return null\n  }\n  // console.log('geturl', res);\n  return res.data.result?.url\n}\n```\n\n```dart flutter \n// 压缩文件对象的抽象逻辑封装\nFuture<File> compressFile(File file) async {\n  Directory dir = await getTemporaryDirectory();\n  String fileType = file.absolute.path.split('.').last;\n  File result = await FlutterImageCompress.compressAndGetFile(\n    file.absolute.path,\n    dir.absolute.path +\n        \"/\" +DateTime.now().millisecondsSinceEpoch.toString() +\".\" +\n        fileType,\n    quality: 88,\n  );\n  return result;\n}\n\n// 可以定义高度的分割线\nDivider standardDivider(double height,Color color=Color(0x15000000)){\n  return  new Divider(\n  height: height,\n  color:  color,\n);\n} \n\n```\n\n## 状态组件\n### 定义\n> 有参数（或隐式的状态初值传参）且本身在生命周期中能持有变量（可变化）的组件\n\n状态组件从编程思想来看，是“面向对象编程”思想的体现；从前端框架的角度来说，笔者觉得完整的状态管理流程链是区分一个前端框架“现代”与否的关键性标准。\n### 举例\n","slug":"工程向-前端框架思路总结-10","published":1,"updated":"2021-10-25T01:29:29.350Z","_id":"ckuld61r40000y96h39jv7crj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 </p>\n<span id=\"more\"></span>\n\n<div class=\"admonition note\"><p class=\"admonition-title\">写在前面\n</p><p>本思路主要应用于<code>以状态管理为核心</code>的前端框架，包括但不限于 <code>react</code>, <code>vue</code>等 web 框架 以及 <code>flutter</code>, <code>swift框架</code> 等非 web 框架</p>\n<p>对于<code>框架对应编程语言的学习</code>暂时不在讨论范围内，不过进行多讨论</p>\n<p>标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷</p>\n</div>\n\n<h1 id=\"封装-is-all-you-need\"><a href=\"#封装-is-all-you-need\" class=\"headerlink\" title=\"封装 is all you need\"></a>封装 is all you need</h1><p>笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：</p>\n<ol>\n<li>三个层次组件的封装方法</li>\n<li>三个层次组件相互嵌套的方法</li>\n</ol>\n<p>一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文</p>\n<div class=\"admonition info\"><p>以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料，不同层次的封装就如水泥钢筋等不同材料，而组件的嵌套是材料使用的流程</p>\n</div>\n\n<h1 id=\"什么是封装？\"><a href=\"#什么是封装？\" class=\"headerlink\" title=\"什么是封装？\"></a>什么是封装？</h1><p>在正式介绍学习思路之前，首先要先总结下前端开发(非限定前端框架)中的“组件封装”</p>\n<blockquote><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体</p>\n<footer><strong>wiki 百科</strong></footer></blockquote>\n<p>在开发过程中，个人认为“封装”的意义关键在于“复用”，是<code>面向对象编程</code>思想的一种表层体现。</p>\n<p>换而言之，如果一个项目的开发需求中几乎不存在可复用的“部分”，那么可以完全抛弃“封装”的概念，采用<code>面向过程编程</code>的思路<br>但如果同一个“部分”不断出现在项目中，那我们应该考虑对他进行抽象其封装来减少维护难度，提高代码鲁棒性。</p>\n<p>具体到前端开发中的封装组件，往往是 UI 和交互逻辑的抽象结合体，典型的例子有如 <a href=\"https://material.io/components/lists\">material 提供的 List 组件</a>: </p>\n<ol>\n<li>提供了统一的样式渲染模版</li>\n<li>透明化内部交互逻辑以及样式渲染</li>\n<li>具有一定的样式或逻辑自定义 API</li>\n</ol>\n<p>当然，简单功能的纯 UI 组件封装也是十分常见，典型的例子有如 <a href=\"https://ant.design/components/typography-cn/\">ant design 提供的 Typography 组件</a></p>\n<p>而纯逻辑封装对于开源资源则较为少见，一是部分前端框架并不提供完全剥离 UI 而只抽象逻辑的封装能力（说的就是你，vue2）；二是单纯的逻辑封装往往意味着与业务逻辑的强耦合关系，很难跨项目通用；三是对于纯逻辑组件意味着更复杂的项目抽象层次与更高的心智成本，大多数时候懒是第一阻力（🐶</p>\n<p>对于纯逻辑封装的典型例子，我想在 <a href=\"\">react hook 的抽象组件封装</a>中单独探讨</p>\n<div class=\"admonition info\"><p>需要注意的是，这里提到的 UI 与 逻辑的抽象封装仅仅只是对封装概念的举例，并不是“封装层次”的总结。笔者想表达的封装层次区分在下一节中介绍</p>\n</div>\n\n<h1 id=\"封装的三个层次\"><a href=\"#封装的三个层次\" class=\"headerlink\" title=\"封装的三个层次\"></a>封装的三个层次</h1><p>学习思路的第一步，了解待学习前端框架三个层次组件的封装方法。下面将结合具体框架中的封装例子从“低层次”到“高层次”分别介绍三种封装层次<br>以下代码举例将主要为 typescript 版本的 react 与 flutter 框架中的代码</p>\n<div class=\"admonition info\"><p>三个层次的名称系笔者自己 yy，可能与专业术语撞车，可能不够贴切，还请见谅</p>\n</div>\n\n<h2 id=\"静态组件\"><a href=\"#静态组件\" class=\"headerlink\" title=\"静态组件\"></a>静态组件</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>无参数且本身在生命周期中不会也不能变化的组件</p>\n</blockquote>\n<p>作为最低层次的封装，静态组件的概念较为简单。从编程语言角度，其实<code>常量</code>本身也是一种静态组件。<br>这样的封装看似意义不大，但是回到上文对于封装必要性的描述，静态组件可以指代一个全局使用的“颜色”，一个全局默认“参数”或是一个重复使用的“样式”等等</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>在大多数前端框架的大多数使用场景中，静态组件的声明和使用与变量无异，在这里就不过多赘述了。</p>\n<pre><div class=\"caption\"><span>react</span></div><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> primaryColor: <span class=\"hljs-built_in\">string</span>  = <span class=\"hljs-string\">&quot;#13acd9&quot;</span>  \n<span class=\"hljs-keyword\">const</span> breakpoint = <span class=\"hljs-string\">&quot;1000px&quot;</span> \n<span class=\"hljs-keyword\">const</span> standardSpace = <span class=\"hljs-function\">()=&gt;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;width:</span>&quot;<span class=\"hljs-attr\">2rem</span>&quot;,<span class=\"hljs-attr\">height:</span>&quot;<span class=\"hljs-attr\">1rem</span>&quot;&#125;&#125;/&gt;</span></span></code></pre>\n\n<pre><div class=\"caption\"><span>flutter</span></div><code class=\"hljs dart\">Color primaryBlue = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFF13ACD9</span>);\nColor primaryRed = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFFFF8585</span>);\nColor primaryGreen = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFF27AE60</span>);\nDivider standardDivider = <span class=\"hljs-keyword\">new</span> Divider(\n  height: <span class=\"hljs-number\">2</span>,\n  color: Color(<span class=\"hljs-number\">0x15000000</span>),\n);</code></pre>\n\n<h2 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>有参数且本身在生命周期中不会也不能变化的组件</p>\n</blockquote>\n<p>在代码层次上，相比静态组件，函数组件本身不再是完全不变的，在实例化时可以接受参数。这给予了函数组件更多的自定义空间<br>但是需要注意的是，顾名思义，函数组件在实例化之后便无法发生变化（如函数执行完成后便退出执行栈，再次执行已经是另一个实例了）</p>\n<h3 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>在笔者看来，函数组件其实是在大多数前端工程中使用最多的，但是很容易用而不自知，因为函数组件的心智成本很低（随便就写了，随便就用了）<br>对于函数组件的深层讨论，我们会在下文介绍状态组件后进行</p>\n<pre><div class=\"caption\"><span>react</span></div><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 一个可以接受参数的占位盒子</span>\n<span class=\"hljs-keyword\">const</span> SizeBox = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; height = <span class=\"hljs-number\">0</span>, width = <span class=\"hljs-number\">0</span> &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">height:</span> <span class=\"hljs-attr\">height</span>, <span class=\"hljs-attr\">width:</span> <span class=\"hljs-attr\">width</span> &#125;&#125;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;\n\n<span class=\"hljs-comment\">// 一个上传流程中抽象的封装逻辑</span>\n<span class=\"hljs-keyword\">const</span> getUploadUrl = <span class=\"hljs-keyword\">async</span> (fileName: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">api</span>: AxiosInstance) =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> api.get(<span class=\"hljs-string\">&#x27;/static/upload&#x27;</span>, &#123; <span class=\"hljs-attr\">params</span>: &#123; fileName &#125; &#125;)\n  <span class=\"hljs-keyword\">if</span> (!res.data.success) &#123;\n    message.error(res.data.reason)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n  &#125;\n  <span class=\"hljs-comment\">// console.log(&#x27;geturl&#x27;, res);</span>\n  <span class=\"hljs-keyword\">return</span> res.data.result?.url\n&#125;</code></pre>\n\n<pre><div class=\"caption\"><span>flutter</span></div><code class=\"hljs dart\"><span class=\"hljs-comment\">// 压缩文件对象的抽象逻辑封装</span>\nFuture&lt;File&gt; compressFile(File file) <span class=\"hljs-keyword\">async</span> &#123;\n  Directory dir = <span class=\"hljs-keyword\">await</span> getTemporaryDirectory();\n  <span class=\"hljs-built_in\">String</span> fileType = file.absolute.path.split(<span class=\"hljs-string\">&#x27;.&#x27;</span>).last;\n  File result = <span class=\"hljs-keyword\">await</span> FlutterImageCompress.compressAndGetFile(\n    file.absolute.path,\n    dir.absolute.path +\n        <span class=\"hljs-string\">&quot;/&quot;</span> +<span class=\"hljs-built_in\">DateTime</span>.now().millisecondsSinceEpoch.toString() +<span class=\"hljs-string\">&quot;.&quot;</span> +\n        fileType,\n    quality: <span class=\"hljs-number\">88</span>,\n  );\n  <span class=\"hljs-keyword\">return</span> result;\n&#125;\n\n<span class=\"hljs-comment\">// 可以定义高度的分割线</span>\nDivider standardDivider(<span class=\"hljs-built_in\">double</span> height,Color color=Color(<span class=\"hljs-number\">0x15000000</span>))&#123;\n  <span class=\"hljs-keyword\">return</span>  <span class=\"hljs-keyword\">new</span> Divider(\n  height: height,\n  color:  color,\n);\n&#125; \n</code></pre>\n\n<h2 id=\"状态组件\"><a href=\"#状态组件\" class=\"headerlink\" title=\"状态组件\"></a>状态组件</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>有参数（或隐式的状态初值传参）且本身在生命周期中能持有变量（可变化）的组件</p>\n</blockquote>\n<p>状态组件从编程思想来看，是“面向对象编程”思想的体现；从前端框架的角度来说，笔者觉得完整的状态管理流程链是区分一个前端框架“现代”与否的关键性标准。</p>\n<h3 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h3>","site":{"data":{}},"excerpt":"<p>本文提供一个现代前端框架的学习与理解思路，从 组件封装层次 切入，加快从看文档到看懂文档到实际上手的过程。 </p>","more":"<div class=\"admonition note\"><p class=\"admonition-title\">写在前面\n</p><p>本思路主要应用于<code>以状态管理为核心</code>的前端框架，包括但不限于 <code>react</code>, <code>vue</code>等 web 框架 以及 <code>flutter</code>, <code>swift框架</code> 等非 web 框架</p>\n<p>对于<code>框架对应编程语言的学习</code>暂时不在讨论范围内，不过进行多讨论</p>\n<p>标题如有雷同纯属巧合（🐶，内容为个人拙见轻喷</p>\n</div>\n\n<h1 id=\"封装-is-all-you-need\"><a href=\"#封装-is-all-you-need\" class=\"headerlink\" title=\"封装 is all you need\"></a>封装 is all you need</h1><p>笔者认为，抛开编程语言细节，对于一个新前端框架的学习思路不外乎以下两步：</p>\n<ol>\n<li>三个层次组件的封装方法</li>\n<li>三个层次组件相互嵌套的方法</li>\n</ol>\n<p>一般的前端项目都存在类似“组件树”的概念，不同的组件在嵌套的父子关系中构建起整个应用，具体思路见下文</p>\n<div class=\"admonition info\"><p>以老土的盖房子做比喻，封装组件就如构造盖房子的建筑材料，不同层次的封装就如水泥钢筋等不同材料，而组件的嵌套是材料使用的流程</p>\n</div>\n\n<h1 id=\"什么是封装？\"><a href=\"#什么是封装？\" class=\"headerlink\" title=\"什么是封装？\"></a>什么是封装？</h1><p>在正式介绍学习思路之前，首先要先总结下前端开发(非限定前端框架)中的“组件封装”</p>\n<blockquote><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体</p>\n<footer><strong>wiki 百科</strong></footer></blockquote>\n<p>在开发过程中，个人认为“封装”的意义关键在于“复用”，是<code>面向对象编程</code>思想的一种表层体现。</p>\n<p>换而言之，如果一个项目的开发需求中几乎不存在可复用的“部分”，那么可以完全抛弃“封装”的概念，采用<code>面向过程编程</code>的思路<br>但如果同一个“部分”不断出现在项目中，那我们应该考虑对他进行抽象其封装来减少维护难度，提高代码鲁棒性。</p>\n<p>具体到前端开发中的封装组件，往往是 UI 和交互逻辑的抽象结合体，典型的例子有如 <a href=\"https://material.io/components/lists\">material 提供的 List 组件</a>: </p>\n<ol>\n<li>提供了统一的样式渲染模版</li>\n<li>透明化内部交互逻辑以及样式渲染</li>\n<li>具有一定的样式或逻辑自定义 API</li>\n</ol>\n<p>当然，简单功能的纯 UI 组件封装也是十分常见，典型的例子有如 <a href=\"https://ant.design/components/typography-cn/\">ant design 提供的 Typography 组件</a></p>\n<p>而纯逻辑封装对于开源资源则较为少见，一是部分前端框架并不提供完全剥离 UI 而只抽象逻辑的封装能力（说的就是你，vue2）；二是单纯的逻辑封装往往意味着与业务逻辑的强耦合关系，很难跨项目通用；三是对于纯逻辑组件意味着更复杂的项目抽象层次与更高的心智成本，大多数时候懒是第一阻力（🐶</p>\n<p>对于纯逻辑封装的典型例子，我想在 <a href=\"\">react hook 的抽象组件封装</a>中单独探讨</p>\n<div class=\"admonition info\"><p>需要注意的是，这里提到的 UI 与 逻辑的抽象封装仅仅只是对封装概念的举例，并不是“封装层次”的总结。笔者想表达的封装层次区分在下一节中介绍</p>\n</div>\n\n<h1 id=\"封装的三个层次\"><a href=\"#封装的三个层次\" class=\"headerlink\" title=\"封装的三个层次\"></a>封装的三个层次</h1><p>学习思路的第一步，了解待学习前端框架三个层次组件的封装方法。下面将结合具体框架中的封装例子从“低层次”到“高层次”分别介绍三种封装层次<br>以下代码举例将主要为 typescript 版本的 react 与 flutter 框架中的代码</p>\n<div class=\"admonition info\"><p>三个层次的名称系笔者自己 yy，可能与专业术语撞车，可能不够贴切，还请见谅</p>\n</div>\n\n<h2 id=\"静态组件\"><a href=\"#静态组件\" class=\"headerlink\" title=\"静态组件\"></a>静态组件</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>无参数且本身在生命周期中不会也不能变化的组件</p>\n</blockquote>\n<p>作为最低层次的封装，静态组件的概念较为简单。从编程语言角度，其实<code>常量</code>本身也是一种静态组件。<br>这样的封装看似意义不大，但是回到上文对于封装必要性的描述，静态组件可以指代一个全局使用的“颜色”，一个全局默认“参数”或是一个重复使用的“样式”等等</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>在大多数前端框架的大多数使用场景中，静态组件的声明和使用与变量无异，在这里就不过多赘述了。</p>\n<pre><div class=\"caption\"><span>react</span></div><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> primaryColor: <span class=\"hljs-built_in\">string</span>  = <span class=\"hljs-string\">&quot;#13acd9&quot;</span>  \n<span class=\"hljs-keyword\">const</span> breakpoint = <span class=\"hljs-string\">&quot;1000px&quot;</span> \n<span class=\"hljs-keyword\">const</span> standardSpace = <span class=\"hljs-function\">()=&gt;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;width:</span>&quot;<span class=\"hljs-attr\">2rem</span>&quot;,<span class=\"hljs-attr\">height:</span>&quot;<span class=\"hljs-attr\">1rem</span>&quot;&#125;&#125;/&gt;</span></span></code></pre>\n\n<pre><div class=\"caption\"><span>flutter</span></div><code class=\"hljs dart\">Color primaryBlue = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFF13ACD9</span>);\nColor primaryRed = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFFFF8585</span>);\nColor primaryGreen = <span class=\"hljs-keyword\">new</span> Color(<span class=\"hljs-number\">0xFF27AE60</span>);\nDivider standardDivider = <span class=\"hljs-keyword\">new</span> Divider(\n  height: <span class=\"hljs-number\">2</span>,\n  color: Color(<span class=\"hljs-number\">0x15000000</span>),\n);</code></pre>\n\n<h2 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>有参数且本身在生命周期中不会也不能变化的组件</p>\n</blockquote>\n<p>在代码层次上，相比静态组件，函数组件本身不再是完全不变的，在实例化时可以接受参数。这给予了函数组件更多的自定义空间<br>但是需要注意的是，顾名思义，函数组件在实例化之后便无法发生变化（如函数执行完成后便退出执行栈，再次执行已经是另一个实例了）</p>\n<h3 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>在笔者看来，函数组件其实是在大多数前端工程中使用最多的，但是很容易用而不自知，因为函数组件的心智成本很低（随便就写了，随便就用了）<br>对于函数组件的深层讨论，我们会在下文介绍状态组件后进行</p>\n<pre><div class=\"caption\"><span>react</span></div><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 一个可以接受参数的占位盒子</span>\n<span class=\"hljs-keyword\">const</span> SizeBox = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; height = <span class=\"hljs-number\">0</span>, width = <span class=\"hljs-number\">0</span> &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">height:</span> <span class=\"hljs-attr\">height</span>, <span class=\"hljs-attr\">width:</span> <span class=\"hljs-attr\">width</span> &#125;&#125;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;\n\n<span class=\"hljs-comment\">// 一个上传流程中抽象的封装逻辑</span>\n<span class=\"hljs-keyword\">const</span> getUploadUrl = <span class=\"hljs-keyword\">async</span> (fileName: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">api</span>: AxiosInstance) =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> api.get(<span class=\"hljs-string\">&#x27;/static/upload&#x27;</span>, &#123; <span class=\"hljs-attr\">params</span>: &#123; fileName &#125; &#125;)\n  <span class=\"hljs-keyword\">if</span> (!res.data.success) &#123;\n    message.error(res.data.reason)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n  &#125;\n  <span class=\"hljs-comment\">// console.log(&#x27;geturl&#x27;, res);</span>\n  <span class=\"hljs-keyword\">return</span> res.data.result?.url\n&#125;</code></pre>\n\n<pre><div class=\"caption\"><span>flutter</span></div><code class=\"hljs dart\"><span class=\"hljs-comment\">// 压缩文件对象的抽象逻辑封装</span>\nFuture&lt;File&gt; compressFile(File file) <span class=\"hljs-keyword\">async</span> &#123;\n  Directory dir = <span class=\"hljs-keyword\">await</span> getTemporaryDirectory();\n  <span class=\"hljs-built_in\">String</span> fileType = file.absolute.path.split(<span class=\"hljs-string\">&#x27;.&#x27;</span>).last;\n  File result = <span class=\"hljs-keyword\">await</span> FlutterImageCompress.compressAndGetFile(\n    file.absolute.path,\n    dir.absolute.path +\n        <span class=\"hljs-string\">&quot;/&quot;</span> +<span class=\"hljs-built_in\">DateTime</span>.now().millisecondsSinceEpoch.toString() +<span class=\"hljs-string\">&quot;.&quot;</span> +\n        fileType,\n    quality: <span class=\"hljs-number\">88</span>,\n  );\n  <span class=\"hljs-keyword\">return</span> result;\n&#125;\n\n<span class=\"hljs-comment\">// 可以定义高度的分割线</span>\nDivider standardDivider(<span class=\"hljs-built_in\">double</span> height,Color color=Color(<span class=\"hljs-number\">0x15000000</span>))&#123;\n  <span class=\"hljs-keyword\">return</span>  <span class=\"hljs-keyword\">new</span> Divider(\n  height: height,\n  color:  color,\n);\n&#125; \n</code></pre>\n\n<h2 id=\"状态组件\"><a href=\"#状态组件\" class=\"headerlink\" title=\"状态组件\"></a>状态组件</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>有参数（或隐式的状态初值传参）且本身在生命周期中能持有变量（可变化）的组件</p>\n</blockquote>\n<p>状态组件从编程思想来看，是“面向对象编程”思想的体现；从前端框架的角度来说，笔者觉得完整的状态管理流程链是区分一个前端框架“现代”与否的关键性标准。</p>\n<h3 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h3>"},{"layout":"ai","title":"初中人工智能教程 头脑风暴","date":"2021-10-05T07:55:51.000Z","_content":"初中学生对于纯理论知识的接收能力有限，应该主要以寓教于乐的形式进行教学，对于知识点的讲解需要主要以实操项目，分步带领学思考和探究内容。\n\n## 项目式（PBL）教学法\n\n项目教学法（Project-based Learning），简称PBL，它是通过“项目”的形式进行教学。在老师的指导下，将一个相对独立的项目交由学生自己处理：收集信息、设计方案、实施项目和最终评价。\n\n我们通过使用项目教学法开展人工智能课程，先练后讲，先学后教，强调学生的自主学习，主动参与，从尝试入手，从练习开始，调动学生学习的主动性、创造性、积极性等。\n\n## 思维导图开展课程\n\n思维导图，是表达发散性思维的有效图形思维工具，它能充分运用左右脑的机能，开启人类大脑的无限潜能，因此思维导图具有人类思维的强大功能。\n\n我们的学生，在受提问表达对某个问题或事件的观点看法时，往往回答是“我们什么都想不到”；部分语文水平不好的学生，则非常害怕写作文，总是“大脑一片空白”……是不是都没有想法呢？其实不然，只是缺乏提取和组织想法的方法工具——思维导图，则可以帮助我们。学生通过一定的思维训练后，可以清晰的表达想法、创造思维，激发头脑风暴，让作品富有创意和个性。\n\n## 激发主观能动性\n\n在课程实践过程中要力求让学生发挥主观能动性，防止过多限制任务进行方向或给予过多主观指引。在课程安排中，让学生进行分组，每人根据不同的项目，自主轮流担任‘司令（产品经理）’、‘通信员（数据信息收集分析反馈）’、‘小兵（程序编写、硬件搭建）’等角色，通过分工合作把项目进行分解分析，创意头脑风暴（思维导图）、数据整理、软硬件的设计，从而完成项目，完成作品。\n\n# 组织架构想法\n\n以激发兴趣，锻炼计算机思维为主体，通过简易项目传输核心思想，不求全面地知识体系教学。\n{:.info}\n\n## 从理论基础到创新实践\n\n1. 基本概念\n2. 不同领域核心思想*N\n   1. 小项目实践\n   2. 现实应用\n3. 不同应用领域*N\n4. 创新实践项目\n5. 安全伦理，未来畅想\n\n## 多个具体应用领域切分\n\n很难避免 “机器学习甚至深度学习 约等于 人工智能” 的错误，但是好像大多数基础教学都默认这一个错误的概念\n\n1. 基本概念\n2. 具体领域*N\n   1. 核心概念\n   2. 简单项目实践\n   3. 现实应用\n3. 安全伦理，未来畅想\n\n## 分两册两个实例\n\n1. 具体实例1\n\n   1. 实例介绍\n   2. 核心思想\n   3. 实例实践\n   4. 拓展\n2. 具体实例2\n\n   1. 实例介绍\n   2. 核心思想\n   3. 实例实践\n   4. 拓展\n\n> ref: http://www.scicat.cn/p/20210530/5254617.html\n>\n> ref: http://47.95.242.172/thesis/view/4790384\n","source":"_posts/人工智能/概论/初中人工智能教程-头脑风暴-10.md","raw":"---\nlayout: ai\ntitle: 初中人工智能教程 头脑风暴\ndate: 2021-10-05 15:55:51\ntags:\n- 机器学习\n- 人工智能\n- 杂七杂八\n\ncategories:\n  - 人工智能\n  - 概论\n---\n初中学生对于纯理论知识的接收能力有限，应该主要以寓教于乐的形式进行教学，对于知识点的讲解需要主要以实操项目，分步带领学思考和探究内容。\n\n## 项目式（PBL）教学法\n\n项目教学法（Project-based Learning），简称PBL，它是通过“项目”的形式进行教学。在老师的指导下，将一个相对独立的项目交由学生自己处理：收集信息、设计方案、实施项目和最终评价。\n\n我们通过使用项目教学法开展人工智能课程，先练后讲，先学后教，强调学生的自主学习，主动参与，从尝试入手，从练习开始，调动学生学习的主动性、创造性、积极性等。\n\n## 思维导图开展课程\n\n思维导图，是表达发散性思维的有效图形思维工具，它能充分运用左右脑的机能，开启人类大脑的无限潜能，因此思维导图具有人类思维的强大功能。\n\n我们的学生，在受提问表达对某个问题或事件的观点看法时，往往回答是“我们什么都想不到”；部分语文水平不好的学生，则非常害怕写作文，总是“大脑一片空白”……是不是都没有想法呢？其实不然，只是缺乏提取和组织想法的方法工具——思维导图，则可以帮助我们。学生通过一定的思维训练后，可以清晰的表达想法、创造思维，激发头脑风暴，让作品富有创意和个性。\n\n## 激发主观能动性\n\n在课程实践过程中要力求让学生发挥主观能动性，防止过多限制任务进行方向或给予过多主观指引。在课程安排中，让学生进行分组，每人根据不同的项目，自主轮流担任‘司令（产品经理）’、‘通信员（数据信息收集分析反馈）’、‘小兵（程序编写、硬件搭建）’等角色，通过分工合作把项目进行分解分析，创意头脑风暴（思维导图）、数据整理、软硬件的设计，从而完成项目，完成作品。\n\n# 组织架构想法\n\n以激发兴趣，锻炼计算机思维为主体，通过简易项目传输核心思想，不求全面地知识体系教学。\n{:.info}\n\n## 从理论基础到创新实践\n\n1. 基本概念\n2. 不同领域核心思想*N\n   1. 小项目实践\n   2. 现实应用\n3. 不同应用领域*N\n4. 创新实践项目\n5. 安全伦理，未来畅想\n\n## 多个具体应用领域切分\n\n很难避免 “机器学习甚至深度学习 约等于 人工智能” 的错误，但是好像大多数基础教学都默认这一个错误的概念\n\n1. 基本概念\n2. 具体领域*N\n   1. 核心概念\n   2. 简单项目实践\n   3. 现实应用\n3. 安全伦理，未来畅想\n\n## 分两册两个实例\n\n1. 具体实例1\n\n   1. 实例介绍\n   2. 核心思想\n   3. 实例实践\n   4. 拓展\n2. 具体实例2\n\n   1. 实例介绍\n   2. 核心思想\n   3. 实例实践\n   4. 拓展\n\n> ref: http://www.scicat.cn/p/20210530/5254617.html\n>\n> ref: http://47.95.242.172/thesis/view/4790384\n","slug":"人工智能-概论-初中人工智能教程-头脑风暴-10","published":1,"updated":"2021-10-10T05:33:36.916Z","comments":1,"photos":[],"link":"","_id":"ckuld61r90004y96h8z0yacho","content":"<p>初中学生对于纯理论知识的接收能力有限，应该主要以寓教于乐的形式进行教学，对于知识点的讲解需要主要以实操项目，分步带领学思考和探究内容。</p>\n<h2 id=\"项目式（PBL）教学法\"><a href=\"#项目式（PBL）教学法\" class=\"headerlink\" title=\"项目式（PBL）教学法\"></a>项目式（PBL）教学法</h2><p>项目教学法（Project-based Learning），简称PBL，它是通过“项目”的形式进行教学。在老师的指导下，将一个相对独立的项目交由学生自己处理：收集信息、设计方案、实施项目和最终评价。</p>\n<p>我们通过使用项目教学法开展人工智能课程，先练后讲，先学后教，强调学生的自主学习，主动参与，从尝试入手，从练习开始，调动学生学习的主动性、创造性、积极性等。</p>\n<h2 id=\"思维导图开展课程\"><a href=\"#思维导图开展课程\" class=\"headerlink\" title=\"思维导图开展课程\"></a>思维导图开展课程</h2><p>思维导图，是表达发散性思维的有效图形思维工具，它能充分运用左右脑的机能，开启人类大脑的无限潜能，因此思维导图具有人类思维的强大功能。</p>\n<p>我们的学生，在受提问表达对某个问题或事件的观点看法时，往往回答是“我们什么都想不到”；部分语文水平不好的学生，则非常害怕写作文，总是“大脑一片空白”……是不是都没有想法呢？其实不然，只是缺乏提取和组织想法的方法工具——思维导图，则可以帮助我们。学生通过一定的思维训练后，可以清晰的表达想法、创造思维，激发头脑风暴，让作品富有创意和个性。</p>\n<h2 id=\"激发主观能动性\"><a href=\"#激发主观能动性\" class=\"headerlink\" title=\"激发主观能动性\"></a>激发主观能动性</h2><p>在课程实践过程中要力求让学生发挥主观能动性，防止过多限制任务进行方向或给予过多主观指引。在课程安排中，让学生进行分组，每人根据不同的项目，自主轮流担任‘司令（产品经理）’、‘通信员（数据信息收集分析反馈）’、‘小兵（程序编写、硬件搭建）’等角色，通过分工合作把项目进行分解分析，创意头脑风暴（思维导图）、数据整理、软硬件的设计，从而完成项目，完成作品。</p>\n<h1 id=\"组织架构想法\"><a href=\"#组织架构想法\" class=\"headerlink\" title=\"组织架构想法\"></a>组织架构想法</h1><p>以激发兴趣，锻炼计算机思维为主体，通过简易项目传输核心思想，不求全面地知识体系教学。<br>{:.info}</p>\n<h2 id=\"从理论基础到创新实践\"><a href=\"#从理论基础到创新实践\" class=\"headerlink\" title=\"从理论基础到创新实践\"></a>从理论基础到创新实践</h2><ol>\n<li>基本概念</li>\n<li>不同领域核心思想*N<ol>\n<li>小项目实践</li>\n<li>现实应用</li>\n</ol>\n</li>\n<li>不同应用领域*N</li>\n<li>创新实践项目</li>\n<li>安全伦理，未来畅想</li>\n</ol>\n<h2 id=\"多个具体应用领域切分\"><a href=\"#多个具体应用领域切分\" class=\"headerlink\" title=\"多个具体应用领域切分\"></a>多个具体应用领域切分</h2><p>很难避免 “机器学习甚至深度学习 约等于 人工智能” 的错误，但是好像大多数基础教学都默认这一个错误的概念</p>\n<ol>\n<li>基本概念</li>\n<li>具体领域*N<ol>\n<li>核心概念</li>\n<li>简单项目实践</li>\n<li>现实应用</li>\n</ol>\n</li>\n<li>安全伦理，未来畅想</li>\n</ol>\n<h2 id=\"分两册两个实例\"><a href=\"#分两册两个实例\" class=\"headerlink\" title=\"分两册两个实例\"></a>分两册两个实例</h2><ol>\n<li><p>具体实例1</p>\n<ol>\n<li>实例介绍</li>\n<li>核心思想</li>\n<li>实例实践</li>\n<li>拓展</li>\n</ol>\n</li>\n<li><p>具体实例2</p>\n<ol>\n<li>实例介绍</li>\n<li>核心思想</li>\n<li>实例实践</li>\n<li>拓展</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>ref: <a href=\"http://www.scicat.cn/p/20210530/5254617.html\">http://www.scicat.cn/p/20210530/5254617.html</a></p>\n<p>ref: <a href=\"http://47.95.242.172/thesis/view/4790384\">http://47.95.242.172/thesis/view/4790384</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>初中学生对于纯理论知识的接收能力有限，应该主要以寓教于乐的形式进行教学，对于知识点的讲解需要主要以实操项目，分步带领学思考和探究内容。</p>\n<h2 id=\"项目式（PBL）教学法\"><a href=\"#项目式（PBL）教学法\" class=\"headerlink\" title=\"项目式（PBL）教学法\"></a>项目式（PBL）教学法</h2><p>项目教学法（Project-based Learning），简称PBL，它是通过“项目”的形式进行教学。在老师的指导下，将一个相对独立的项目交由学生自己处理：收集信息、设计方案、实施项目和最终评价。</p>\n<p>我们通过使用项目教学法开展人工智能课程，先练后讲，先学后教，强调学生的自主学习，主动参与，从尝试入手，从练习开始，调动学生学习的主动性、创造性、积极性等。</p>\n<h2 id=\"思维导图开展课程\"><a href=\"#思维导图开展课程\" class=\"headerlink\" title=\"思维导图开展课程\"></a>思维导图开展课程</h2><p>思维导图，是表达发散性思维的有效图形思维工具，它能充分运用左右脑的机能，开启人类大脑的无限潜能，因此思维导图具有人类思维的强大功能。</p>\n<p>我们的学生，在受提问表达对某个问题或事件的观点看法时，往往回答是“我们什么都想不到”；部分语文水平不好的学生，则非常害怕写作文，总是“大脑一片空白”……是不是都没有想法呢？其实不然，只是缺乏提取和组织想法的方法工具——思维导图，则可以帮助我们。学生通过一定的思维训练后，可以清晰的表达想法、创造思维，激发头脑风暴，让作品富有创意和个性。</p>\n<h2 id=\"激发主观能动性\"><a href=\"#激发主观能动性\" class=\"headerlink\" title=\"激发主观能动性\"></a>激发主观能动性</h2><p>在课程实践过程中要力求让学生发挥主观能动性，防止过多限制任务进行方向或给予过多主观指引。在课程安排中，让学生进行分组，每人根据不同的项目，自主轮流担任‘司令（产品经理）’、‘通信员（数据信息收集分析反馈）’、‘小兵（程序编写、硬件搭建）’等角色，通过分工合作把项目进行分解分析，创意头脑风暴（思维导图）、数据整理、软硬件的设计，从而完成项目，完成作品。</p>\n<h1 id=\"组织架构想法\"><a href=\"#组织架构想法\" class=\"headerlink\" title=\"组织架构想法\"></a>组织架构想法</h1><p>以激发兴趣，锻炼计算机思维为主体，通过简易项目传输核心思想，不求全面地知识体系教学。<br>{:.info}</p>\n<h2 id=\"从理论基础到创新实践\"><a href=\"#从理论基础到创新实践\" class=\"headerlink\" title=\"从理论基础到创新实践\"></a>从理论基础到创新实践</h2><ol>\n<li>基本概念</li>\n<li>不同领域核心思想*N<ol>\n<li>小项目实践</li>\n<li>现实应用</li>\n</ol>\n</li>\n<li>不同应用领域*N</li>\n<li>创新实践项目</li>\n<li>安全伦理，未来畅想</li>\n</ol>\n<h2 id=\"多个具体应用领域切分\"><a href=\"#多个具体应用领域切分\" class=\"headerlink\" title=\"多个具体应用领域切分\"></a>多个具体应用领域切分</h2><p>很难避免 “机器学习甚至深度学习 约等于 人工智能” 的错误，但是好像大多数基础教学都默认这一个错误的概念</p>\n<ol>\n<li>基本概念</li>\n<li>具体领域*N<ol>\n<li>核心概念</li>\n<li>简单项目实践</li>\n<li>现实应用</li>\n</ol>\n</li>\n<li>安全伦理，未来畅想</li>\n</ol>\n<h2 id=\"分两册两个实例\"><a href=\"#分两册两个实例\" class=\"headerlink\" title=\"分两册两个实例\"></a>分两册两个实例</h2><ol>\n<li><p>具体实例1</p>\n<ol>\n<li>实例介绍</li>\n<li>核心思想</li>\n<li>实例实践</li>\n<li>拓展</li>\n</ol>\n</li>\n<li><p>具体实例2</p>\n<ol>\n<li>实例介绍</li>\n<li>核心思想</li>\n<li>实例实践</li>\n<li>拓展</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>ref: <a href=\"http://www.scicat.cn/p/20210530/5254617.html\">http://www.scicat.cn/p/20210530/5254617.html</a></p>\n<p>ref: <a href=\"http://47.95.242.172/thesis/view/4790384\">http://47.95.242.172/thesis/view/4790384</a></p>\n</blockquote>\n"},{"title":"懒人的 TODO LIST","date":"2021-10-09T13:33:15.000Z","_content":"![img](/images/bg-1.png)\n\n> 本文仅用来鞭策懒惰的自己\n>\n> 一切以最终想法为准.jpg\n\n# 工程向\n\n* [ ] 前端框架通用学习思路\n* [ ] 基于 provider 的 flutter 应用封装\n* [ ] react hook 的组件抽象总结\n* [ ] 基于 VSCodium 的全集C插件开发\n\n# 科研向\n\n* [ ] 伪装目标识别综述\n* [ ] transformer 在扁平数据 embedding 任务上的应用尝试\n* [ ] 一个失败的质谱仪物质分类孪生网络\n* [ ] swin transformer 理解杂谈\n","source":"_posts/杂谈/懒人的-TODO-LIST-10.md","raw":"---\ntitle: 懒人的 TODO LIST\ntags:\n  - 杂七杂八\ncategories:\n  - 杂谈\ndate: 2021-10-09 21:33:15\n---\n![img](/images/bg-1.png)\n\n> 本文仅用来鞭策懒惰的自己\n>\n> 一切以最终想法为准.jpg\n\n# 工程向\n\n* [ ] 前端框架通用学习思路\n* [ ] 基于 provider 的 flutter 应用封装\n* [ ] react hook 的组件抽象总结\n* [ ] 基于 VSCodium 的全集C插件开发\n\n# 科研向\n\n* [ ] 伪装目标识别综述\n* [ ] transformer 在扁平数据 embedding 任务上的应用尝试\n* [ ] 一个失败的质谱仪物质分类孪生网络\n* [ ] swin transformer 理解杂谈\n","slug":"杂谈-懒人的-TODO-LIST-10","published":1,"updated":"2021-10-25T01:28:04.982Z","_id":"ckuld61ra0005y96h35dj2v27","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/bg-1.png\" alt=\"img\"></p>\n<blockquote>\n<p>本文仅用来鞭策懒惰的自己</p>\n<p>一切以最终想法为准.jpg</p>\n</blockquote>\n<h1 id=\"工程向\"><a href=\"#工程向\" class=\"headerlink\" title=\"工程向\"></a>工程向</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 前端框架通用学习思路</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于 provider 的 flutter 应用封装</li>\n<li><input disabled=\"\" type=\"checkbox\"> react hook 的组件抽象总结</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于 VSCodium 的全集C插件开发</li>\n</ul>\n<h1 id=\"科研向\"><a href=\"#科研向\" class=\"headerlink\" title=\"科研向\"></a>科研向</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 伪装目标识别综述</li>\n<li><input disabled=\"\" type=\"checkbox\"> transformer 在扁平数据 embedding 任务上的应用尝试</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一个失败的质谱仪物质分类孪生网络</li>\n<li><input disabled=\"\" type=\"checkbox\"> swin transformer 理解杂谈</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/bg-1.png\" alt=\"img\"></p>\n<blockquote>\n<p>本文仅用来鞭策懒惰的自己</p>\n<p>一切以最终想法为准.jpg</p>\n</blockquote>\n<h1 id=\"工程向\"><a href=\"#工程向\" class=\"headerlink\" title=\"工程向\"></a>工程向</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 前端框架通用学习思路</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于 provider 的 flutter 应用封装</li>\n<li><input disabled=\"\" type=\"checkbox\"> react hook 的组件抽象总结</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于 VSCodium 的全集C插件开发</li>\n</ul>\n<h1 id=\"科研向\"><a href=\"#科研向\" class=\"headerlink\" title=\"科研向\"></a>科研向</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 伪装目标识别综述</li>\n<li><input disabled=\"\" type=\"checkbox\"> transformer 在扁平数据 embedding 任务上的应用尝试</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一个失败的质谱仪物质分类孪生网络</li>\n<li><input disabled=\"\" type=\"checkbox\"> swin transformer 理解杂谈</li>\n</ul>\n"},{"title":"对人工智能哲学的讨论与一点拙见","date":"2022-04-24T05:55:51.000Z","_content":"**人工智能**(artificial intelligence， AI) 的概念自从1956年诞生以来，已然经历了60多年的发展。在这期间伴随着神经科学、计算机科学以及人工智能学科本身的发展，**联结主义**与**符号主义**两种人工智能发展路径间不断相互摩擦、超越乃至于融合，从第一代与第二代人工智能的“牙牙学语”，逐渐形成了当前人工智能迈向“第三代”的发展局面。本文将从**科学角度**与**哲学角度**结合分析两种主要发展路径的核心思想与局限性，并从人工智能研究者的角度对当前人工智能哲学研究做出笔者视角的讨论与反思。\n\n!!! info **写在文前 1 ：**\n    在广义的人工智能哲学研究中，除了联结主义与符号主义，常常还存在**行为主义**这一发展路径。其是由 MIT Brook教授 进行细化和定义的。行为主义大多认为意识不仅有大脑的参与，而是整个身体系统共同作用的结果，其背后反映的是具身哲学的思想。\n\n    但笔者认为，行为主义本身并没有逃脱出联结主义对神经科学的解构范畴，仅仅只是具像化了其中生物体反应外界的一部分“联结”。因此，本文将对行为主义的探讨并入联结主义的讨论范畴。\n\n!!! info **写在文前 2 ：**\n    从人工智能定义以及所应用的科学方法角度出发，将人工智能方法分类为所谓的两种路径是很不严谨的，例如支持向量机方法是一种典型的人工智能（机器学习）方法，但其实它并没有蕴含过多符号主义或者联结主义的思想。另外，因为符号主义出现较早，其横跨了机器学习概念的出现前后，而联结主义出现较晚，其与机器学习概念甚至是深度学习概念几乎重合，而人工智能概念包括机器学习，机器学习概念包括深度学习，这也导致两种“主义”分类的尴尬。在这里指出后，本文将依照传统的研究思路进行讨论，相当于先容忍了这种不严谨。\n\n## 符号主义\n\n在多数研究工作中，符号主义人工智能被归类为第一代人工智能，它主张人类思维的基本单元是符号，人类认知的过程是符号运算，表现为知识表示和推理。符号主义人工智能擅长研究人类的逻辑思维活动，学习过程是从经验或规则出发，根据前提推出结论的过程，采用从一般到特殊的演绎式推理，是一种“自上而下”的模式。\n\n符号主义人工智能的基础是公理化理论和数理逻辑，特点在于逻辑推理过程是可解释和错误可追溯的，换句话说，符号主义人工智能因为其遵循普遍数理逻辑，其行为的可解释性很高，同时较难出现预期之外的行为，更为可控。\n\n符号主义人工智能的早期探索主要是逻辑推理的研究，即如何使用逻辑符号系统来表达逻辑思维的过程，因而又被称为“逻辑主义”。基于为特定任务的逻辑推理研究，产生了早期人工智能领域大规模应用的**专家系统**。但是，早期专家系统所“学会的逻辑推理”是由程序编写者制定的，一个显然的局限是知识获取瓶颈。知识引导的人工智能之所以能展示知识推理等智能化行为，是因为它运用了常识或专家知识。人工智能根据专家知识来执行专家的任务，其推理引擎高度依赖专家知识获取，但这些知识库是封闭的，并且需要由领域专家来构建专家知识，因而，无法自主获取知识，这也是专家系统在当前已然被淘汰主要原因。但随着知识表示技术的发展，出现了以**知识图谱**为首的现代知识表示方法，可以对普遍存在于人类社会的多模态知识进行抽取、抽象、建模，并且通过抽象知识表示进行一定的数理逻辑推理。但同时，因为引入了高级的知识表示抽象，知识推理部分的可解释性显然降低了。\n\n在哲学范畴中，符号主义一直面临一个经典的悖论问题：**哥德尔不完全性定理**。其证明了对于任何一个公理化系统，都存在此公理体系所无法判定真伪的命题。这表明符号系统构建的逻辑形式系统不可能是无所不包的，它无法保证在完备的形式系统中推出所有为真的结论，即不可能同时满足“完备性”和“无矛盾性”两个特征。因而，不存在一个无所不能的符号化人工智能系统。\n\n但现阶段的人工智能还处于追赶人类智能阶段，而不是追赶“上帝”的阶段，而人类本身显然也不可能是一个无所不包的全能“符号”系统。因此，笔者认为符号主义当前面临的哲学问题主要还是“**符号主义是否能在哲学意义上概括人脑的运行机制？**”。由于符号主义纲领的基础是数理逻辑，而形式化与确定性是数理逻辑的重要特点。众多哲学家由此认为这是符号主义模拟“人类情感与意识”的最根本障碍，因为“显然人类的情感与意识是无法形式化的”，笔者对此表示怀疑，会在[笔者反思章节](#笔者反思)中具体讨论。\n\n## 联结主义\n\n类似的，在多数研究工作中，联结主义人工智能被归类为第二代人工智能，它的核心思想来源于神经科学，采用的是由特殊到一般的归纳式推理，依赖的是假设检验、相关性分析、线性预测、时间序列分析等数学方法，学习过程是从大数据中发现隐藏的特征和规律，拟合反映特征的正面数据，排除特征异常的反面数据，这种学习方式是一种“自下而上”的模式。\n\n联结主义理论起源于人们对于大脑结构与工作方式的研究。大脑由大量的神经细胞构成脑中神经细胞的数量应该为$40×10^9$左右，其中有1／5的神经细胞位于大脑新皮层，这一部分被认为负责包括语言处理在内的各种认知活动。大脑皮层的一个细胞平均与其他细胞具有4000个联结，那么在大脑新皮层部分就有$3.3×10^{13}$个联结。这些神经细胞密切相连构成一个复杂的网络系统。每一个神经细胞都可以被看做是一个简单处理器，这些处理器收集输入的电化学脉冲，当输入的信号总量达到一定程度时，神经细胞就会产生行动电位（指神经脉冲的传递过程中在神经细胞表面发生的电位的暂时变化），并通过神经纤维把脉冲传递到神经轴突（为输出端）和神经纤维的分支上。可以看出，上述过程已经和现代神经网络实现非常相似，也是深度学习方法的核心。\n\n笔者认为，从科学角度来说联结主义系统通过模仿人类大脑的运作机理来实现对人类智能的模仿，可以说是相比符号主义更接近“意识”的实现。现实应用的效果也证实了这一点，当今深度学习方法已然证明了自己在推理，感知，生成等领域的统治力，在个别任务中已经能与人旗鼓相当甚至借助计算资源的优势超越人类，典型代表如计算机视觉领域中，人眼都难以辨认的伪装目标识别。\n\n同时相对的，因为以深度学习为首的联结主义方法中利用的是“万千神经元的相互作用”，其输出结果的不确定性与黑箱效应尤为严重，在复杂感知任务中几乎无法将模型某部分的“激活”与“未激活”解释为对输出的特定影响。但庆幸的是，当前对于深度学习可解释性的研究是很火热的，已经产出了众多卓有成效的方法。\n\n## 两种路径的关系\n\n笔者认为，现阶段两种路径的关系几乎是正交的，并不是水火不容的，甚至本身两种主义的哲学层次就是相互不影响的。符号主义的核心思想主要集中于用形式化系统描述人类智能，其主要应用集中于现代知识建模方法如知识图谱，但是知识图谱的核心推理步骤以及自然语言处理部分依然大规模应用深度学习方法；联结主义的核心是利用模仿人类大脑的神经结构完成，但是其核心运算依然是用广义的形式化系统在描述特征与“情感”（深度学习网络能在图灵机上运行，其必然可以被拆分为严格的数理推理过程，简而言之就是逃不开加减乘除四则运算）。因此，哲学意义上，两种路径在当前的人工智能领域中已然形成了你中有我，我中有你的难以分割局面。\n\n## 笔者反思\n\n结合前文提到的两种路径分类严重不严谨问题，笔者认为在当前人工智能研究已然超出了提出“联结主义”与“符号主义”的研究者的想象，逐渐作为一个“人工智能”整体，在发展路径上越走越远了。划句话说，其已经逐渐成为一个严肃的、需要定量讨论的科学问题，希望在哲学层次总结出一个人工智能发展路径已然不具有太多现实意义，或者换句话说，通过分析符号主义与联结主义，已经不太能得出有意义的，“真正具有情感”人工智能的哲学思想了。\n\n那难道我们就只能失去对未来“能完全模拟人的强人工智能”的哲学设想了吗？笔者认为不是的，甚至当前的人工智能发展水平已经接触到了“强人工智能”的范畴。以下给出一些管中窥豹，抛砖引玉的个人观点与现实例子，以证明上述笔者的拙见：\n\n1. 欧陆哲学指出，人类所谓的情感与意识，以及其外现出的行为，大部分来自于对以往经验的抽象总结与泛化，换句绝对一点的话说，就是人的意识本质是记忆组成的，如果没有记忆，人脑就像一个没有插电的电脑，只是一个空转的执行器，执行着生理本能，而不会产生“意识”。典型例子就是极强的正向或反向刺激，会在人脑中迅速形成“习惯”、“癖好”乃至“成瘾”。\n2. 美国FACEBOOK公司旗下的人工智能研究机构 FAIR，在2022年初（也就是最近）发布了其最新的图像语言感知模型 「DALLE2」。DALLE2 能在完全没有额外数据训练的情况下，输入自然语言描述，输出语言描述的图像。\n3. DALLE2 模型其使用的核心部分 transformer 模型，在2020年至2022年间有多篇论文已经证明其应用于自然语言任务时，可能只是记住了训练数据中的特定语句进行问答（如用于问答任务时，如果待选回答皆为模型没有见过的新语句，其基本无法回答正确）。\n4. 人类大脑在不同的环境中，接收不同层次的教育，可能完全表现出不同的智商水平以及感知能力。\n5. 人类的“泛化能力”并不是大多数人想象中那么强，典型例子就是四维空间的想象，人脑就完全无法做到，以及初生的婴儿并不能通过认识苹果，自己认识梨。\n\n结合以上观点以及事实，我们可以总结出：\n\n!!! note 核心观点\n    虽然当前人工智能方法因为其“无法像人一样举一反三”以及“好像仅仅记住了训练数据”而被认为离强人工智能很远，但有没有可能，即便是仅仅记住了某些过往经验，其实就和人脑的执行逻辑没有哲学意义上的巨大鸿沟了呢。因为人脑其实也只是利用神经元的化学结构与物理结构“记住了”过往的所见所闻，并且因此改变了对外界的反应。而所谓的完全泛化能力，其实人脑也无法做到，只是因为大多数人在几十年的人生生涯中见过的事物太多，基本很难遇到经验中找不到的。\n\n上述给出的 DALLE2 模型，在笔者看来就是通过高层次抽象的“记忆”，产生了已经能和人相似的感知，推理能力。\n","source":"_posts/杂谈/对人工智能哲学的讨论与一点拙见.md","raw":"---\ntitle: 对人工智能哲学的讨论与一点拙见\ntags:\n  - 人工智能哲学\n  - 杂七杂八\ncategories:\n  - 杂谈\ndate: 2022-4-24 13:55:51\n---\n**人工智能**(artificial intelligence， AI) 的概念自从1956年诞生以来，已然经历了60多年的发展。在这期间伴随着神经科学、计算机科学以及人工智能学科本身的发展，**联结主义**与**符号主义**两种人工智能发展路径间不断相互摩擦、超越乃至于融合，从第一代与第二代人工智能的“牙牙学语”，逐渐形成了当前人工智能迈向“第三代”的发展局面。本文将从**科学角度**与**哲学角度**结合分析两种主要发展路径的核心思想与局限性，并从人工智能研究者的角度对当前人工智能哲学研究做出笔者视角的讨论与反思。\n\n!!! info **写在文前 1 ：**\n    在广义的人工智能哲学研究中，除了联结主义与符号主义，常常还存在**行为主义**这一发展路径。其是由 MIT Brook教授 进行细化和定义的。行为主义大多认为意识不仅有大脑的参与，而是整个身体系统共同作用的结果，其背后反映的是具身哲学的思想。\n\n    但笔者认为，行为主义本身并没有逃脱出联结主义对神经科学的解构范畴，仅仅只是具像化了其中生物体反应外界的一部分“联结”。因此，本文将对行为主义的探讨并入联结主义的讨论范畴。\n\n!!! info **写在文前 2 ：**\n    从人工智能定义以及所应用的科学方法角度出发，将人工智能方法分类为所谓的两种路径是很不严谨的，例如支持向量机方法是一种典型的人工智能（机器学习）方法，但其实它并没有蕴含过多符号主义或者联结主义的思想。另外，因为符号主义出现较早，其横跨了机器学习概念的出现前后，而联结主义出现较晚，其与机器学习概念甚至是深度学习概念几乎重合，而人工智能概念包括机器学习，机器学习概念包括深度学习，这也导致两种“主义”分类的尴尬。在这里指出后，本文将依照传统的研究思路进行讨论，相当于先容忍了这种不严谨。\n\n## 符号主义\n\n在多数研究工作中，符号主义人工智能被归类为第一代人工智能，它主张人类思维的基本单元是符号，人类认知的过程是符号运算，表现为知识表示和推理。符号主义人工智能擅长研究人类的逻辑思维活动，学习过程是从经验或规则出发，根据前提推出结论的过程，采用从一般到特殊的演绎式推理，是一种“自上而下”的模式。\n\n符号主义人工智能的基础是公理化理论和数理逻辑，特点在于逻辑推理过程是可解释和错误可追溯的，换句话说，符号主义人工智能因为其遵循普遍数理逻辑，其行为的可解释性很高，同时较难出现预期之外的行为，更为可控。\n\n符号主义人工智能的早期探索主要是逻辑推理的研究，即如何使用逻辑符号系统来表达逻辑思维的过程，因而又被称为“逻辑主义”。基于为特定任务的逻辑推理研究，产生了早期人工智能领域大规模应用的**专家系统**。但是，早期专家系统所“学会的逻辑推理”是由程序编写者制定的，一个显然的局限是知识获取瓶颈。知识引导的人工智能之所以能展示知识推理等智能化行为，是因为它运用了常识或专家知识。人工智能根据专家知识来执行专家的任务，其推理引擎高度依赖专家知识获取，但这些知识库是封闭的，并且需要由领域专家来构建专家知识，因而，无法自主获取知识，这也是专家系统在当前已然被淘汰主要原因。但随着知识表示技术的发展，出现了以**知识图谱**为首的现代知识表示方法，可以对普遍存在于人类社会的多模态知识进行抽取、抽象、建模，并且通过抽象知识表示进行一定的数理逻辑推理。但同时，因为引入了高级的知识表示抽象，知识推理部分的可解释性显然降低了。\n\n在哲学范畴中，符号主义一直面临一个经典的悖论问题：**哥德尔不完全性定理**。其证明了对于任何一个公理化系统，都存在此公理体系所无法判定真伪的命题。这表明符号系统构建的逻辑形式系统不可能是无所不包的，它无法保证在完备的形式系统中推出所有为真的结论，即不可能同时满足“完备性”和“无矛盾性”两个特征。因而，不存在一个无所不能的符号化人工智能系统。\n\n但现阶段的人工智能还处于追赶人类智能阶段，而不是追赶“上帝”的阶段，而人类本身显然也不可能是一个无所不包的全能“符号”系统。因此，笔者认为符号主义当前面临的哲学问题主要还是“**符号主义是否能在哲学意义上概括人脑的运行机制？**”。由于符号主义纲领的基础是数理逻辑，而形式化与确定性是数理逻辑的重要特点。众多哲学家由此认为这是符号主义模拟“人类情感与意识”的最根本障碍，因为“显然人类的情感与意识是无法形式化的”，笔者对此表示怀疑，会在[笔者反思章节](#笔者反思)中具体讨论。\n\n## 联结主义\n\n类似的，在多数研究工作中，联结主义人工智能被归类为第二代人工智能，它的核心思想来源于神经科学，采用的是由特殊到一般的归纳式推理，依赖的是假设检验、相关性分析、线性预测、时间序列分析等数学方法，学习过程是从大数据中发现隐藏的特征和规律，拟合反映特征的正面数据，排除特征异常的反面数据，这种学习方式是一种“自下而上”的模式。\n\n联结主义理论起源于人们对于大脑结构与工作方式的研究。大脑由大量的神经细胞构成脑中神经细胞的数量应该为$40×10^9$左右，其中有1／5的神经细胞位于大脑新皮层，这一部分被认为负责包括语言处理在内的各种认知活动。大脑皮层的一个细胞平均与其他细胞具有4000个联结，那么在大脑新皮层部分就有$3.3×10^{13}$个联结。这些神经细胞密切相连构成一个复杂的网络系统。每一个神经细胞都可以被看做是一个简单处理器，这些处理器收集输入的电化学脉冲，当输入的信号总量达到一定程度时，神经细胞就会产生行动电位（指神经脉冲的传递过程中在神经细胞表面发生的电位的暂时变化），并通过神经纤维把脉冲传递到神经轴突（为输出端）和神经纤维的分支上。可以看出，上述过程已经和现代神经网络实现非常相似，也是深度学习方法的核心。\n\n笔者认为，从科学角度来说联结主义系统通过模仿人类大脑的运作机理来实现对人类智能的模仿，可以说是相比符号主义更接近“意识”的实现。现实应用的效果也证实了这一点，当今深度学习方法已然证明了自己在推理，感知，生成等领域的统治力，在个别任务中已经能与人旗鼓相当甚至借助计算资源的优势超越人类，典型代表如计算机视觉领域中，人眼都难以辨认的伪装目标识别。\n\n同时相对的，因为以深度学习为首的联结主义方法中利用的是“万千神经元的相互作用”，其输出结果的不确定性与黑箱效应尤为严重，在复杂感知任务中几乎无法将模型某部分的“激活”与“未激活”解释为对输出的特定影响。但庆幸的是，当前对于深度学习可解释性的研究是很火热的，已经产出了众多卓有成效的方法。\n\n## 两种路径的关系\n\n笔者认为，现阶段两种路径的关系几乎是正交的，并不是水火不容的，甚至本身两种主义的哲学层次就是相互不影响的。符号主义的核心思想主要集中于用形式化系统描述人类智能，其主要应用集中于现代知识建模方法如知识图谱，但是知识图谱的核心推理步骤以及自然语言处理部分依然大规模应用深度学习方法；联结主义的核心是利用模仿人类大脑的神经结构完成，但是其核心运算依然是用广义的形式化系统在描述特征与“情感”（深度学习网络能在图灵机上运行，其必然可以被拆分为严格的数理推理过程，简而言之就是逃不开加减乘除四则运算）。因此，哲学意义上，两种路径在当前的人工智能领域中已然形成了你中有我，我中有你的难以分割局面。\n\n## 笔者反思\n\n结合前文提到的两种路径分类严重不严谨问题，笔者认为在当前人工智能研究已然超出了提出“联结主义”与“符号主义”的研究者的想象，逐渐作为一个“人工智能”整体，在发展路径上越走越远了。划句话说，其已经逐渐成为一个严肃的、需要定量讨论的科学问题，希望在哲学层次总结出一个人工智能发展路径已然不具有太多现实意义，或者换句话说，通过分析符号主义与联结主义，已经不太能得出有意义的，“真正具有情感”人工智能的哲学思想了。\n\n那难道我们就只能失去对未来“能完全模拟人的强人工智能”的哲学设想了吗？笔者认为不是的，甚至当前的人工智能发展水平已经接触到了“强人工智能”的范畴。以下给出一些管中窥豹，抛砖引玉的个人观点与现实例子，以证明上述笔者的拙见：\n\n1. 欧陆哲学指出，人类所谓的情感与意识，以及其外现出的行为，大部分来自于对以往经验的抽象总结与泛化，换句绝对一点的话说，就是人的意识本质是记忆组成的，如果没有记忆，人脑就像一个没有插电的电脑，只是一个空转的执行器，执行着生理本能，而不会产生“意识”。典型例子就是极强的正向或反向刺激，会在人脑中迅速形成“习惯”、“癖好”乃至“成瘾”。\n2. 美国FACEBOOK公司旗下的人工智能研究机构 FAIR，在2022年初（也就是最近）发布了其最新的图像语言感知模型 「DALLE2」。DALLE2 能在完全没有额外数据训练的情况下，输入自然语言描述，输出语言描述的图像。\n3. DALLE2 模型其使用的核心部分 transformer 模型，在2020年至2022年间有多篇论文已经证明其应用于自然语言任务时，可能只是记住了训练数据中的特定语句进行问答（如用于问答任务时，如果待选回答皆为模型没有见过的新语句，其基本无法回答正确）。\n4. 人类大脑在不同的环境中，接收不同层次的教育，可能完全表现出不同的智商水平以及感知能力。\n5. 人类的“泛化能力”并不是大多数人想象中那么强，典型例子就是四维空间的想象，人脑就完全无法做到，以及初生的婴儿并不能通过认识苹果，自己认识梨。\n\n结合以上观点以及事实，我们可以总结出：\n\n!!! note 核心观点\n    虽然当前人工智能方法因为其“无法像人一样举一反三”以及“好像仅仅记住了训练数据”而被认为离强人工智能很远，但有没有可能，即便是仅仅记住了某些过往经验，其实就和人脑的执行逻辑没有哲学意义上的巨大鸿沟了呢。因为人脑其实也只是利用神经元的化学结构与物理结构“记住了”过往的所见所闻，并且因此改变了对外界的反应。而所谓的完全泛化能力，其实人脑也无法做到，只是因为大多数人在几十年的人生生涯中见过的事物太多，基本很难遇到经验中找不到的。\n\n上述给出的 DALLE2 模型，在笔者看来就是通过高层次抽象的“记忆”，产生了已经能和人相似的感知，推理能力。\n","slug":"杂谈-对人工智能哲学的讨论与一点拙见","published":1,"updated":"2022-04-24T16:32:30.337Z","_id":"cl2dibt4k0000ag6h85sm7xzy","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>人工智能</strong>(artificial intelligence， AI) 的概念自从1956年诞生以来，已然经历了60多年的发展。在这期间伴随着神经科学、计算机科学以及人工智能学科本身的发展，<strong>联结主义</strong>与<strong>符号主义</strong>两种人工智能发展路径间不断相互摩擦、超越乃至于融合，从第一代与第二代人工智能的“牙牙学语”，逐渐形成了当前人工智能迈向“第三代”的发展局面。本文将从<strong>科学角度</strong>与<strong>哲学角度</strong>结合分析两种主要发展路径的核心思想与局限性，并从人工智能研究者的角度对当前人工智能哲学研究做出笔者视角的讨论与反思。</p>\n<div class=\"admonition info\"><p class=\"admonition-title\">**写在文前 1 ：**\n</p><p>在广义的人工智能哲学研究中，除了联结主义与符号主义，常常还存在<strong>行为主义</strong>这一发展路径。其是由 MIT Brook教授 进行细化和定义的。行为主义大多认为意识不仅有大脑的参与，而是整个身体系统共同作用的结果，其背后反映的是具身哲学的思想。</p>\n<p>但笔者认为，行为主义本身并没有逃脱出联结主义对神经科学的解构范畴，仅仅只是具像化了其中生物体反应外界的一部分“联结”。因此，本文将对行为主义的探讨并入联结主义的讨论范畴。</p>\n</div>\n\n<div class=\"admonition info\"><p class=\"admonition-title\">**写在文前 2 ：**\n</p><p>从人工智能定义以及所应用的科学方法角度出发，将人工智能方法分类为所谓的两种路径是很不严谨的，例如支持向量机方法是一种典型的人工智能（机器学习）方法，但其实它并没有蕴含过多符号主义或者联结主义的思想。另外，因为符号主义出现较早，其横跨了机器学习概念的出现前后，而联结主义出现较晚，其与机器学习概念甚至是深度学习概念几乎重合，而人工智能概念包括机器学习，机器学习概念包括深度学习，这也导致两种“主义”分类的尴尬。在这里指出后，本文将依照传统的研究思路进行讨论，相当于先容忍了这种不严谨。</p>\n</div>\n\n<h2 id=\"符号主义\"><a href=\"#符号主义\" class=\"headerlink\" title=\"符号主义\"></a>符号主义</h2><p>在多数研究工作中，符号主义人工智能被归类为第一代人工智能，它主张人类思维的基本单元是符号，人类认知的过程是符号运算，表现为知识表示和推理。符号主义人工智能擅长研究人类的逻辑思维活动，学习过程是从经验或规则出发，根据前提推出结论的过程，采用从一般到特殊的演绎式推理，是一种“自上而下”的模式。</p>\n<p>符号主义人工智能的基础是公理化理论和数理逻辑，特点在于逻辑推理过程是可解释和错误可追溯的，换句话说，符号主义人工智能因为其遵循普遍数理逻辑，其行为的可解释性很高，同时较难出现预期之外的行为，更为可控。</p>\n<p>符号主义人工智能的早期探索主要是逻辑推理的研究，即如何使用逻辑符号系统来表达逻辑思维的过程，因而又被称为“逻辑主义”。基于为特定任务的逻辑推理研究，产生了早期人工智能领域大规模应用的<strong>专家系统</strong>。但是，早期专家系统所“学会的逻辑推理”是由程序编写者制定的，一个显然的局限是知识获取瓶颈。知识引导的人工智能之所以能展示知识推理等智能化行为，是因为它运用了常识或专家知识。人工智能根据专家知识来执行专家的任务，其推理引擎高度依赖专家知识获取，但这些知识库是封闭的，并且需要由领域专家来构建专家知识，因而，无法自主获取知识，这也是专家系统在当前已然被淘汰主要原因。但随着知识表示技术的发展，出现了以<strong>知识图谱</strong>为首的现代知识表示方法，可以对普遍存在于人类社会的多模态知识进行抽取、抽象、建模，并且通过抽象知识表示进行一定的数理逻辑推理。但同时，因为引入了高级的知识表示抽象，知识推理部分的可解释性显然降低了。</p>\n<p>在哲学范畴中，符号主义一直面临一个经典的悖论问题：<strong>哥德尔不完全性定理</strong>。其证明了对于任何一个公理化系统，都存在此公理体系所无法判定真伪的命题。这表明符号系统构建的逻辑形式系统不可能是无所不包的，它无法保证在完备的形式系统中推出所有为真的结论，即不可能同时满足“完备性”和“无矛盾性”两个特征。因而，不存在一个无所不能的符号化人工智能系统。</p>\n<p>但现阶段的人工智能还处于追赶人类智能阶段，而不是追赶“上帝”的阶段，而人类本身显然也不可能是一个无所不包的全能“符号”系统。因此，笔者认为符号主义当前面临的哲学问题主要还是“<strong>符号主义是否能在哲学意义上概括人脑的运行机制？</strong>”。由于符号主义纲领的基础是数理逻辑，而形式化与确定性是数理逻辑的重要特点。众多哲学家由此认为这是符号主义模拟“人类情感与意识”的最根本障碍，因为“显然人类的情感与意识是无法形式化的”，笔者对此表示怀疑，会在<a href=\"#%E7%AC%94%E8%80%85%E5%8F%8D%E6%80%9D\">笔者反思章节</a>中具体讨论。</p>\n<h2 id=\"联结主义\"><a href=\"#联结主义\" class=\"headerlink\" title=\"联结主义\"></a>联结主义</h2><p>类似的，在多数研究工作中，联结主义人工智能被归类为第二代人工智能，它的核心思想来源于神经科学，采用的是由特殊到一般的归纳式推理，依赖的是假设检验、相关性分析、线性预测、时间序列分析等数学方法，学习过程是从大数据中发现隐藏的特征和规律，拟合反映特征的正面数据，排除特征异常的反面数据，这种学习方式是一种“自下而上”的模式。</p>\n<p>联结主义理论起源于人们对于大脑结构与工作方式的研究。大脑由大量的神经细胞构成脑中神经细胞的数量应该为$40×10^9$左右，其中有1／5的神经细胞位于大脑新皮层，这一部分被认为负责包括语言处理在内的各种认知活动。大脑皮层的一个细胞平均与其他细胞具有4000个联结，那么在大脑新皮层部分就有$3.3×10^{13}$个联结。这些神经细胞密切相连构成一个复杂的网络系统。每一个神经细胞都可以被看做是一个简单处理器，这些处理器收集输入的电化学脉冲，当输入的信号总量达到一定程度时，神经细胞就会产生行动电位（指神经脉冲的传递过程中在神经细胞表面发生的电位的暂时变化），并通过神经纤维把脉冲传递到神经轴突（为输出端）和神经纤维的分支上。可以看出，上述过程已经和现代神经网络实现非常相似，也是深度学习方法的核心。</p>\n<p>笔者认为，从科学角度来说联结主义系统通过模仿人类大脑的运作机理来实现对人类智能的模仿，可以说是相比符号主义更接近“意识”的实现。现实应用的效果也证实了这一点，当今深度学习方法已然证明了自己在推理，感知，生成等领域的统治力，在个别任务中已经能与人旗鼓相当甚至借助计算资源的优势超越人类，典型代表如计算机视觉领域中，人眼都难以辨认的伪装目标识别。</p>\n<p>同时相对的，因为以深度学习为首的联结主义方法中利用的是“万千神经元的相互作用”，其输出结果的不确定性与黑箱效应尤为严重，在复杂感知任务中几乎无法将模型某部分的“激活”与“未激活”解释为对输出的特定影响。但庆幸的是，当前对于深度学习可解释性的研究是很火热的，已经产出了众多卓有成效的方法。</p>\n<h2 id=\"两种路径的关系\"><a href=\"#两种路径的关系\" class=\"headerlink\" title=\"两种路径的关系\"></a>两种路径的关系</h2><p>笔者认为，现阶段两种路径的关系几乎是正交的，并不是水火不容的，甚至本身两种主义的哲学层次就是相互不影响的。符号主义的核心思想主要集中于用形式化系统描述人类智能，其主要应用集中于现代知识建模方法如知识图谱，但是知识图谱的核心推理步骤以及自然语言处理部分依然大规模应用深度学习方法；联结主义的核心是利用模仿人类大脑的神经结构完成，但是其核心运算依然是用广义的形式化系统在描述特征与“情感”（深度学习网络能在图灵机上运行，其必然可以被拆分为严格的数理推理过程，简而言之就是逃不开加减乘除四则运算）。因此，哲学意义上，两种路径在当前的人工智能领域中已然形成了你中有我，我中有你的难以分割局面。</p>\n<h2 id=\"笔者反思\"><a href=\"#笔者反思\" class=\"headerlink\" title=\"笔者反思\"></a>笔者反思</h2><p>结合前文提到的两种路径分类严重不严谨问题，笔者认为在当前人工智能研究已然超出了提出“联结主义”与“符号主义”的研究者的想象，逐渐作为一个“人工智能”整体，在发展路径上越走越远了。划句话说，其已经逐渐成为一个严肃的、需要定量讨论的科学问题，希望在哲学层次总结出一个人工智能发展路径已然不具有太多现实意义，或者换句话说，通过分析符号主义与联结主义，已经不太能得出有意义的，“真正具有情感”人工智能的哲学思想了。</p>\n<p>那难道我们就只能失去对未来“能完全模拟人的强人工智能”的哲学设想了吗？笔者认为不是的，甚至当前的人工智能发展水平已经接触到了“强人工智能”的范畴。以下给出一些管中窥豹，抛砖引玉的个人观点与现实例子，以证明上述笔者的拙见：</p>\n<ol>\n<li>欧陆哲学指出，人类所谓的情感与意识，以及其外现出的行为，大部分来自于对以往经验的抽象总结与泛化，换句绝对一点的话说，就是人的意识本质是记忆组成的，如果没有记忆，人脑就像一个没有插电的电脑，只是一个空转的执行器，执行着生理本能，而不会产生“意识”。典型例子就是极强的正向或反向刺激，会在人脑中迅速形成“习惯”、“癖好”乃至“成瘾”。</li>\n<li>美国FACEBOOK公司旗下的人工智能研究机构 FAIR，在2022年初（也就是最近）发布了其最新的图像语言感知模型 「DALLE2」。DALLE2 能在完全没有额外数据训练的情况下，输入自然语言描述，输出语言描述的图像。</li>\n<li>DALLE2 模型其使用的核心部分 transformer 模型，在2020年至2022年间有多篇论文已经证明其应用于自然语言任务时，可能只是记住了训练数据中的特定语句进行问答（如用于问答任务时，如果待选回答皆为模型没有见过的新语句，其基本无法回答正确）。</li>\n<li>人类大脑在不同的环境中，接收不同层次的教育，可能完全表现出不同的智商水平以及感知能力。</li>\n<li>人类的“泛化能力”并不是大多数人想象中那么强，典型例子就是四维空间的想象，人脑就完全无法做到，以及初生的婴儿并不能通过认识苹果，自己认识梨。</li>\n</ol>\n<p>结合以上观点以及事实，我们可以总结出：</p>\n<div class=\"admonition note\"><p class=\"admonition-title\">核心观点\n</p><p>虽然当前人工智能方法因为其“无法像人一样举一反三”以及“好像仅仅记住了训练数据”而被认为离强人工智能很远，但有没有可能，即便是仅仅记住了某些过往经验，其实就和人脑的执行逻辑没有哲学意义上的巨大鸿沟了呢。因为人脑其实也只是利用神经元的化学结构与物理结构“记住了”过往的所见所闻，并且因此改变了对外界的反应。而所谓的完全泛化能力，其实人脑也无法做到，只是因为大多数人在几十年的人生生涯中见过的事物太多，基本很难遇到经验中找不到的。</p>\n</div>\n\n<p>上述给出的 DALLE2 模型，在笔者看来就是通过高层次抽象的“记忆”，产生了已经能和人相似的感知，推理能力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>人工智能</strong>(artificial intelligence， AI) 的概念自从1956年诞生以来，已然经历了60多年的发展。在这期间伴随着神经科学、计算机科学以及人工智能学科本身的发展，<strong>联结主义</strong>与<strong>符号主义</strong>两种人工智能发展路径间不断相互摩擦、超越乃至于融合，从第一代与第二代人工智能的“牙牙学语”，逐渐形成了当前人工智能迈向“第三代”的发展局面。本文将从<strong>科学角度</strong>与<strong>哲学角度</strong>结合分析两种主要发展路径的核心思想与局限性，并从人工智能研究者的角度对当前人工智能哲学研究做出笔者视角的讨论与反思。</p>\n<div class=\"admonition info\"><p class=\"admonition-title\">**写在文前 1 ：**\n</p><p>在广义的人工智能哲学研究中，除了联结主义与符号主义，常常还存在<strong>行为主义</strong>这一发展路径。其是由 MIT Brook教授 进行细化和定义的。行为主义大多认为意识不仅有大脑的参与，而是整个身体系统共同作用的结果，其背后反映的是具身哲学的思想。</p>\n<p>但笔者认为，行为主义本身并没有逃脱出联结主义对神经科学的解构范畴，仅仅只是具像化了其中生物体反应外界的一部分“联结”。因此，本文将对行为主义的探讨并入联结主义的讨论范畴。</p>\n</div>\n\n<div class=\"admonition info\"><p class=\"admonition-title\">**写在文前 2 ：**\n</p><p>从人工智能定义以及所应用的科学方法角度出发，将人工智能方法分类为所谓的两种路径是很不严谨的，例如支持向量机方法是一种典型的人工智能（机器学习）方法，但其实它并没有蕴含过多符号主义或者联结主义的思想。另外，因为符号主义出现较早，其横跨了机器学习概念的出现前后，而联结主义出现较晚，其与机器学习概念甚至是深度学习概念几乎重合，而人工智能概念包括机器学习，机器学习概念包括深度学习，这也导致两种“主义”分类的尴尬。在这里指出后，本文将依照传统的研究思路进行讨论，相当于先容忍了这种不严谨。</p>\n</div>\n\n<h2 id=\"符号主义\"><a href=\"#符号主义\" class=\"headerlink\" title=\"符号主义\"></a>符号主义</h2><p>在多数研究工作中，符号主义人工智能被归类为第一代人工智能，它主张人类思维的基本单元是符号，人类认知的过程是符号运算，表现为知识表示和推理。符号主义人工智能擅长研究人类的逻辑思维活动，学习过程是从经验或规则出发，根据前提推出结论的过程，采用从一般到特殊的演绎式推理，是一种“自上而下”的模式。</p>\n<p>符号主义人工智能的基础是公理化理论和数理逻辑，特点在于逻辑推理过程是可解释和错误可追溯的，换句话说，符号主义人工智能因为其遵循普遍数理逻辑，其行为的可解释性很高，同时较难出现预期之外的行为，更为可控。</p>\n<p>符号主义人工智能的早期探索主要是逻辑推理的研究，即如何使用逻辑符号系统来表达逻辑思维的过程，因而又被称为“逻辑主义”。基于为特定任务的逻辑推理研究，产生了早期人工智能领域大规模应用的<strong>专家系统</strong>。但是，早期专家系统所“学会的逻辑推理”是由程序编写者制定的，一个显然的局限是知识获取瓶颈。知识引导的人工智能之所以能展示知识推理等智能化行为，是因为它运用了常识或专家知识。人工智能根据专家知识来执行专家的任务，其推理引擎高度依赖专家知识获取，但这些知识库是封闭的，并且需要由领域专家来构建专家知识，因而，无法自主获取知识，这也是专家系统在当前已然被淘汰主要原因。但随着知识表示技术的发展，出现了以<strong>知识图谱</strong>为首的现代知识表示方法，可以对普遍存在于人类社会的多模态知识进行抽取、抽象、建模，并且通过抽象知识表示进行一定的数理逻辑推理。但同时，因为引入了高级的知识表示抽象，知识推理部分的可解释性显然降低了。</p>\n<p>在哲学范畴中，符号主义一直面临一个经典的悖论问题：<strong>哥德尔不完全性定理</strong>。其证明了对于任何一个公理化系统，都存在此公理体系所无法判定真伪的命题。这表明符号系统构建的逻辑形式系统不可能是无所不包的，它无法保证在完备的形式系统中推出所有为真的结论，即不可能同时满足“完备性”和“无矛盾性”两个特征。因而，不存在一个无所不能的符号化人工智能系统。</p>\n<p>但现阶段的人工智能还处于追赶人类智能阶段，而不是追赶“上帝”的阶段，而人类本身显然也不可能是一个无所不包的全能“符号”系统。因此，笔者认为符号主义当前面临的哲学问题主要还是“<strong>符号主义是否能在哲学意义上概括人脑的运行机制？</strong>”。由于符号主义纲领的基础是数理逻辑，而形式化与确定性是数理逻辑的重要特点。众多哲学家由此认为这是符号主义模拟“人类情感与意识”的最根本障碍，因为“显然人类的情感与意识是无法形式化的”，笔者对此表示怀疑，会在<a href=\"#%E7%AC%94%E8%80%85%E5%8F%8D%E6%80%9D\">笔者反思章节</a>中具体讨论。</p>\n<h2 id=\"联结主义\"><a href=\"#联结主义\" class=\"headerlink\" title=\"联结主义\"></a>联结主义</h2><p>类似的，在多数研究工作中，联结主义人工智能被归类为第二代人工智能，它的核心思想来源于神经科学，采用的是由特殊到一般的归纳式推理，依赖的是假设检验、相关性分析、线性预测、时间序列分析等数学方法，学习过程是从大数据中发现隐藏的特征和规律，拟合反映特征的正面数据，排除特征异常的反面数据，这种学习方式是一种“自下而上”的模式。</p>\n<p>联结主义理论起源于人们对于大脑结构与工作方式的研究。大脑由大量的神经细胞构成脑中神经细胞的数量应该为$40×10^9$左右，其中有1／5的神经细胞位于大脑新皮层，这一部分被认为负责包括语言处理在内的各种认知活动。大脑皮层的一个细胞平均与其他细胞具有4000个联结，那么在大脑新皮层部分就有$3.3×10^{13}$个联结。这些神经细胞密切相连构成一个复杂的网络系统。每一个神经细胞都可以被看做是一个简单处理器，这些处理器收集输入的电化学脉冲，当输入的信号总量达到一定程度时，神经细胞就会产生行动电位（指神经脉冲的传递过程中在神经细胞表面发生的电位的暂时变化），并通过神经纤维把脉冲传递到神经轴突（为输出端）和神经纤维的分支上。可以看出，上述过程已经和现代神经网络实现非常相似，也是深度学习方法的核心。</p>\n<p>笔者认为，从科学角度来说联结主义系统通过模仿人类大脑的运作机理来实现对人类智能的模仿，可以说是相比符号主义更接近“意识”的实现。现实应用的效果也证实了这一点，当今深度学习方法已然证明了自己在推理，感知，生成等领域的统治力，在个别任务中已经能与人旗鼓相当甚至借助计算资源的优势超越人类，典型代表如计算机视觉领域中，人眼都难以辨认的伪装目标识别。</p>\n<p>同时相对的，因为以深度学习为首的联结主义方法中利用的是“万千神经元的相互作用”，其输出结果的不确定性与黑箱效应尤为严重，在复杂感知任务中几乎无法将模型某部分的“激活”与“未激活”解释为对输出的特定影响。但庆幸的是，当前对于深度学习可解释性的研究是很火热的，已经产出了众多卓有成效的方法。</p>\n<h2 id=\"两种路径的关系\"><a href=\"#两种路径的关系\" class=\"headerlink\" title=\"两种路径的关系\"></a>两种路径的关系</h2><p>笔者认为，现阶段两种路径的关系几乎是正交的，并不是水火不容的，甚至本身两种主义的哲学层次就是相互不影响的。符号主义的核心思想主要集中于用形式化系统描述人类智能，其主要应用集中于现代知识建模方法如知识图谱，但是知识图谱的核心推理步骤以及自然语言处理部分依然大规模应用深度学习方法；联结主义的核心是利用模仿人类大脑的神经结构完成，但是其核心运算依然是用广义的形式化系统在描述特征与“情感”（深度学习网络能在图灵机上运行，其必然可以被拆分为严格的数理推理过程，简而言之就是逃不开加减乘除四则运算）。因此，哲学意义上，两种路径在当前的人工智能领域中已然形成了你中有我，我中有你的难以分割局面。</p>\n<h2 id=\"笔者反思\"><a href=\"#笔者反思\" class=\"headerlink\" title=\"笔者反思\"></a>笔者反思</h2><p>结合前文提到的两种路径分类严重不严谨问题，笔者认为在当前人工智能研究已然超出了提出“联结主义”与“符号主义”的研究者的想象，逐渐作为一个“人工智能”整体，在发展路径上越走越远了。划句话说，其已经逐渐成为一个严肃的、需要定量讨论的科学问题，希望在哲学层次总结出一个人工智能发展路径已然不具有太多现实意义，或者换句话说，通过分析符号主义与联结主义，已经不太能得出有意义的，“真正具有情感”人工智能的哲学思想了。</p>\n<p>那难道我们就只能失去对未来“能完全模拟人的强人工智能”的哲学设想了吗？笔者认为不是的，甚至当前的人工智能发展水平已经接触到了“强人工智能”的范畴。以下给出一些管中窥豹，抛砖引玉的个人观点与现实例子，以证明上述笔者的拙见：</p>\n<ol>\n<li>欧陆哲学指出，人类所谓的情感与意识，以及其外现出的行为，大部分来自于对以往经验的抽象总结与泛化，换句绝对一点的话说，就是人的意识本质是记忆组成的，如果没有记忆，人脑就像一个没有插电的电脑，只是一个空转的执行器，执行着生理本能，而不会产生“意识”。典型例子就是极强的正向或反向刺激，会在人脑中迅速形成“习惯”、“癖好”乃至“成瘾”。</li>\n<li>美国FACEBOOK公司旗下的人工智能研究机构 FAIR，在2022年初（也就是最近）发布了其最新的图像语言感知模型 「DALLE2」。DALLE2 能在完全没有额外数据训练的情况下，输入自然语言描述，输出语言描述的图像。</li>\n<li>DALLE2 模型其使用的核心部分 transformer 模型，在2020年至2022年间有多篇论文已经证明其应用于自然语言任务时，可能只是记住了训练数据中的特定语句进行问答（如用于问答任务时，如果待选回答皆为模型没有见过的新语句，其基本无法回答正确）。</li>\n<li>人类大脑在不同的环境中，接收不同层次的教育，可能完全表现出不同的智商水平以及感知能力。</li>\n<li>人类的“泛化能力”并不是大多数人想象中那么强，典型例子就是四维空间的想象，人脑就完全无法做到，以及初生的婴儿并不能通过认识苹果，自己认识梨。</li>\n</ol>\n<p>结合以上观点以及事实，我们可以总结出：</p>\n<div class=\"admonition note\"><p class=\"admonition-title\">核心观点\n</p><p>虽然当前人工智能方法因为其“无法像人一样举一反三”以及“好像仅仅记住了训练数据”而被认为离强人工智能很远，但有没有可能，即便是仅仅记住了某些过往经验，其实就和人脑的执行逻辑没有哲学意义上的巨大鸿沟了呢。因为人脑其实也只是利用神经元的化学结构与物理结构“记住了”过往的所见所闻，并且因此改变了对外界的反应。而所谓的完全泛化能力，其实人脑也无法做到，只是因为大多数人在几十年的人生生涯中见过的事物太多，基本很难遇到经验中找不到的。</p>\n</div>\n\n<p>上述给出的 DALLE2 模型，在笔者看来就是通过高层次抽象的“记忆”，产生了已经能和人相似的感知，推理能力。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckuld61r40000y96h39jv7crj","category_id":"ckuld61r80002y96hedd6cklw","_id":"ckuld61rd0008y96hg2gf3i73"},{"post_id":"ckuld61ra0005y96h35dj2v27","category_id":"ckuld61rc0006y96h58qe8sdj","_id":"ckuld61rg000iy96h3dvhdums"},{"post_id":"ckuld61r90004y96h8z0yacho","category_id":"ckuld61rd0009y96h6c8z1np2","_id":"ckuld61rg000ly96ha1ww7vx8"},{"post_id":"ckuld61r90004y96h8z0yacho","category_id":"ckuld61rf000gy96hf77wgw9e","_id":"ckuld61rh000ny96h022r1y76"},{"post_id":"cl2dibt4k0000ag6h85sm7xzy","category_id":"ckuld61rc0006y96h58qe8sdj","_id":"cl2dibt4q0001ag6h3x3f0mzm"}],"PostTag":[{"post_id":"ckuld61r40000y96h39jv7crj","tag_id":"ckuld61r90003y96h6w948b79","_id":"ckuld61rd000by96h7r0550d9"},{"post_id":"ckuld61r40000y96h39jv7crj","tag_id":"ckuld61rc0007y96hcmy6ady4","_id":"ckuld61re000cy96h9aj91ne6"},{"post_id":"ckuld61r90004y96h8z0yacho","tag_id":"ckuld61rd000ay96h1l018486","_id":"ckuld61rg000ky96h4czm9axy"},{"post_id":"ckuld61r90004y96h8z0yacho","tag_id":"ckuld61re000fy96h2w69fdfl","_id":"ckuld61rg000my96h3fet7xgc"},{"post_id":"ckuld61r90004y96h8z0yacho","tag_id":"ckuld61rg000hy96h23hd9rlh","_id":"ckuld61rh000oy96h4r93cy1f"},{"post_id":"ckuld61ra0005y96h35dj2v27","tag_id":"ckuld61rg000hy96h23hd9rlh","_id":"ckuld61rh000py96hepyf5mmg"},{"post_id":"cl2dibt4k0000ag6h85sm7xzy","tag_id":"cl2didux40000fv6h107n34jw","_id":"cl2didux60001fv6he0xocctt"},{"post_id":"cl2dibt4k0000ag6h85sm7xzy","tag_id":"ckuld61rg000hy96h23hd9rlh","_id":"cl2didux60002fv6h00pw37es"}],"Tag":[{"name":"前端工程","_id":"ckuld61r90003y96h6w948b79"},{"name":"学习思路","_id":"ckuld61rc0007y96hcmy6ady4"},{"name":"机器学习","_id":"ckuld61rd000ay96h1l018486"},{"name":"人工智能","_id":"ckuld61re000fy96h2w69fdfl"},{"name":"杂七杂八","_id":"ckuld61rg000hy96h23hd9rlh"},{"name":"人工智能哲学","_id":"cl2didux40000fv6h107n34jw"}]}}